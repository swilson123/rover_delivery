'use strict';

var vendor = require('./vendor.js');
var logger = require('../external/@socketsecurity/registry/lib/logger');
var strings = require('../external/@socketsecurity/registry/lib/strings');
var require$$9 = require('../external/@socketsecurity/registry/lib/debug');
var require$$11 = require('../external/@socketsecurity/registry/lib/objects');
var constants = require('./constants.js');
var arrays = require('../external/@socketsecurity/registry/lib/arrays');
var path$1 = require('../external/@socketsecurity/registry/lib/path');
var sorts = require('../external/@socketsecurity/registry/lib/sorts');
var spinner = require('../external/@socketsecurity/registry/lib/spinner');
var words = require('../external/@socketsecurity/registry/lib/words');
var flags = require('./flags.js');
var path = require('node:path');
var regexps = require('../external/@socketsecurity/registry/lib/regexps');
var prompts = require('../external/@socketsecurity/registry/lib/prompts');
var spawn = require('../external/@socketsecurity/registry/lib/spawn');
var fs = require('../external/@socketsecurity/registry/lib/fs');
var require$$5 = require('node:module');
var fs$1 = require('node:fs');
var require$$13 = require('../external/@socketsecurity/registry/lib/url');
var agent = require('../external/@socketsecurity/registry/lib/agent');
var bin = require('../external/@socketsecurity/registry/lib/bin');
var packages = require('../external/@socketsecurity/registry/lib/packages');
var require$$0 = require('node:url');
var globs = require('../external/@socketsecurity/registry/lib/globs');
var streams = require('../external/@socketsecurity/registry/lib/streams');
var promises = require('node:timers/promises');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
/**
 * Debug utilities for Socket CLI.
 * Provides structured debugging with categorized levels and helpers.
 *
 * Debug Categories:
 * DEFAULT (shown with SOCKET_CLI_DEBUG=1):
 * - 'error': Critical errors that prevent operation
 * - 'warn': Important warnings that may affect behavior
 * - 'notice': Notable events and state changes
 * - 'silly': Very verbose debugging info
 *
 * OPT-IN ONLY (require explicit DEBUG='category' even with SOCKET_CLI_DEBUG=1):
 * - 'inspect': Detailed object inspection (DEBUG='inspect' or DEBUG='*')
 * - 'stdio': Command execution logs (DEBUG='stdio' or DEBUG='*')
 *
 * These opt-in categories are intentionally excluded from default debug output
 * to reduce noise. Enable them explicitly when needed for deep debugging.
 */


/**
 * Debug an API response.
 * Logs essential info without exposing sensitive data.
 */
function debugApiResponse(endpoint, status, error) {
  if (error) {
    require$$9.debugDir('error', {
      endpoint,
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  } else if (status && status >= 400) {
    require$$9.debugFn('warn', `API ${endpoint}: HTTP ${status}`);
  } else if (require$$9.isDebug('notice')) {
    require$$9.debugFn('notice', `API ${endpoint}: ${status || 'pending'}`);
  }
}

/**
 * Debug file operation.
 * Logs file operations with appropriate level.
 */
function debugFileOp(operation, filepath, error) {
  if (error) {
    require$$9.debugDir('warn', {
      operation,
      filepath,
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  } else if (require$$9.isDebug('silly')) {
    require$$9.debugFn('silly', `File ${operation}: ${filepath}`);
  }
}

/**
 * Debug package scanning.
 * Provides insight into security scanning.
 */
function debugScan(phase, packageCount, details) {
  switch (phase) {
    case 'start':
      if (packageCount) {
        require$$9.debugFn('notice', `Scanning ${packageCount} packages`);
      }
      break;
    case 'progress':
      if (require$$9.isDebug('silly') && packageCount) {
        require$$9.debugFn('silly', `Scan progress: ${packageCount} packages processed`);
      }
      break;
    case 'complete':
      require$$9.debugFn('notice', `Scan complete${packageCount ? `: ${packageCount} packages` : ''}`);
      break;
    case 'error':
      require$$9.debugDir('error', {
        phase: 'scan_error',
        details
      });
      break;
  }
}

/**
 * Debug configuration loading.
 */
function debugConfig(source, found, error) {
  if (error) {
    require$$9.debugDir('warn', {
      source,
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  } else if (found) {
    require$$9.debugFn('notice', `Config loaded: ${source}`);
  } else if (require$$9.isDebug('silly')) {
    require$$9.debugFn('silly', `Config not found: ${source}`);
  }
}

/**
 * Debug git operations.
 * Only logs important git operations, not every command.
 */
function debugGit(operation, success, details) {
  if (!success) {
    require$$9.debugDir('warn', {
      git_op: operation,
      ...details
    });
  } else if (require$$9.isDebug('notice') && operation.includes('push') || operation.includes('commit')) {
    // Only log important operations like push and commit.
    require$$9.debugFn('notice', `Git ${operation} succeeded`);
  } else if (require$$9.isDebug('silly')) {
    require$$9.debugFn('silly', `Git ${operation}`);
  }
}

/**
 * Error utilities for Socket CLI.
 * Provides consistent error handling, formatting, and message extraction.
 *
 * Key Classes:
 * - AuthError: Authentication failures (401/403 responses)
 * - InputError: User input validation failures
 *
 * Key Functions:
 * - captureException: Send errors to Sentry for monitoring
 * - formatErrorWithDetail: Format errors with detailed context
 * - getErrorCause: Get error cause with fallback to UNKNOWN_ERROR
 * - getErrorMessage: Extract error message from any thrown value
 *
 * Error Handling Strategy:
 * - Always prefer specific error types over generic errors
 * - Use formatErrorWithDetail for user-facing error messages
 * - Log errors to Sentry in production for monitoring
 */

const {
  kInternalsSymbol,
  [kInternalsSymbol]: {
    getSentry
  }
} = constants.default;
class AuthError extends Error {}
class InputError extends Error {
  constructor(message, body) {
    super(message);
    this.body = body;
  }
}
async function captureException(exception, hint) {
  const result = captureExceptionSync(exception, hint);
  // "Sleep" for a second, just in case, hopefully enough time to initiate fetch.
  await promises.setTimeout(1000);
  return result;
}
function captureExceptionSync(exception, hint) {
  const Sentry = getSentry();
  if (!Sentry) {
    return '';
  }
  require$$9.debugFn('notice', 'send: exception to Sentry');
  return Sentry.captureException(exception, hint);
}

/**
 * Extracts an error message from an unknown value.
 * Returns the message if it's an Error object, otherwise returns undefined.
 *
 * @param error - The error object to extract message from
 * @returns The error message or undefined
 */
function getErrorMessage(error) {
  return error?.message;
}

/**
 * Extracts an error message from an unknown value with a fallback.
 * Returns the message if it's an Error object, otherwise returns the fallback.
 *
 * @param error - The error object to extract message from
 * @param fallback - The fallback message if no error message is found
 * @returns The error message or fallback
 *
 * @example
 * getErrorMessageOr(error, 'Unknown error occurred')
 * // Returns: "ENOENT: no such file or directory" or "Unknown error occurred"
 */
function getErrorMessageOr(error, fallback) {
  return getErrorMessage(error) || fallback;
}

/**
 * Extracts an error cause from an unknown value.
 * Returns the error message if available, otherwise UNKNOWN_ERROR.
 * Commonly used for creating CResult error causes.
 *
 * @param error - The error object to extract message from
 * @returns The error message or UNKNOWN_ERROR constant
 *
 * @example
 * return { ok: false, message: 'Operation failed', cause: getErrorCause(e) }
 */
function getErrorCause(error) {
  return getErrorMessageOr(error, constants.UNKNOWN_ERROR);
}

/**
 * Formats an error message with an optional error detail appended.
 * Extracts the message from an unknown error value and appends it
 * to the base message if available.
 *
 * @param baseMessage - The base message to display
 * @param error - The error object to extract message from
 * @returns Formatted message with error detail if available
 *
 * @example
 * formatErrorWithDetail('Failed to delete file', error)
 * // Returns: "Failed to delete file: ENOENT: no such file or directory"
 * // Or just: "Failed to delete file" if no error message
 */
function formatErrorWithDetail(baseMessage, error) {
  const errorMessage = getErrorMessage(error);
  return `${baseMessage}${errorMessage ? `: ${errorMessage}` : ''}`;
}

/**
 * Configuration utilities for Socket CLI.
 * Manages CLI configuration including API tokens, org settings, and preferences.
 *
 * Configuration Hierarchy (highest priority first):
 * 1. Environment variables (SOCKET_CLI_*)
 * 2. Command-line --config flag
 * 3. Persisted config file (base64 encoded JSON)
 *
 * Supported Config Keys:
 * - apiBaseUrl: Socket API endpoint URL
 * - apiProxy: Proxy for API requests
 * - apiToken: Authentication token for Socket API
 * - defaultOrg/org: Default organization slug
 * - enforcedOrgs: Organizations with enforced security policies
 *
 * Key Functions:
 * - findSocketYmlSync: Locate socket.yml configuration file
 * - getConfigValue: Retrieve configuration value by key
 * - overrideCachedConfig: Apply temporary config overrides
 * - updateConfigValue: Persist configuration changes
 */

const sensitiveConfigKeyLookup = new Set([constants.CONFIG_KEY_API_TOKEN]);
const supportedConfig = new Map([[constants.CONFIG_KEY_API_BASE_URL, 'Base URL of the Socket API endpoint'], [constants.CONFIG_KEY_API_PROXY, 'A proxy through which to access the Socket API'], [constants.CONFIG_KEY_API_TOKEN, 'The Socket API token required to access most Socket API endpoints'], [constants.CONFIG_KEY_DEFAULT_ORG, 'The default org slug to use; usually the org your Socket API token has access to. When set, all orgSlug arguments are implied to be this value.'], [constants.CONFIG_KEY_ENFORCED_ORGS, 'Orgs in this list have their security policies enforced on this machine'], ['skipAskToPersistDefaultOrg', 'This flag prevents the Socket CLI from asking you to persist the org slug when you selected one interactively'], [constants.CONFIG_KEY_ORG, 'Alias for defaultOrg']]);
const supportedConfigEntries = [...supportedConfig.entries()].sort((a, b) => sorts.naturalCompare(a[0], b[0]));
const supportedConfigKeys = supportedConfigEntries.map(p => p[0]);
function getConfigValues() {
  if (_cachedConfig === undefined) {
    // Order: env var > --config flag > file
    _cachedConfig = {};
    const {
      socketAppDataPath
    } = constants.default;
    if (socketAppDataPath) {
      const raw = fs.safeReadFileSync(socketAppDataPath);
      if (raw) {
        try {
          Object.assign(_cachedConfig, JSON.parse(Buffer.from(raw, 'base64').toString()));
          debugConfig(socketAppDataPath, true);
        } catch (e) {
          logger.logger.warn(`Failed to parse config at ${socketAppDataPath}`);
          debugConfig(socketAppDataPath, false, e);
        }
        // Normalize apiKey to apiToken and persist it.
        // This is a one time migration per user.
        if (_cachedConfig['apiKey']) {
          const token = _cachedConfig['apiKey'];
          delete _cachedConfig['apiKey'];
          updateConfigValue(constants.CONFIG_KEY_API_TOKEN, token);
        }
      } else {
        fs$1.mkdirSync(path.dirname(socketAppDataPath), {
          recursive: true
        });
      }
    }
  }
  return _cachedConfig;
}
function normalizeConfigKey(key) {
  // Note: apiKey was the old name of the token. When we load a config with
  //       property apiKey, we'll copy that to apiToken and delete the old property.
  // We added `org` as a convenience alias for `defaultOrg`
  const normalizedKey = key === 'apiKey' ? constants.CONFIG_KEY_API_TOKEN : key === constants.CONFIG_KEY_ORG ? constants.CONFIG_KEY_DEFAULT_ORG : key;
  if (!isSupportedConfigKey(normalizedKey)) {
    return {
      ok: false,
      message: `Invalid config key: ${normalizedKey}`,
      data: undefined
    };
  }
  return {
    ok: true,
    data: normalizedKey
  };
}
function findSocketYmlSync(dir = process.cwd()) {
  let prevDir = null;
  while (dir !== prevDir) {
    let ymlPath = path.join(dir, constants.SOCKET_YML);
    let yml = fs.safeReadFileSync(ymlPath);
    if (yml === undefined) {
      ymlPath = path.join(dir, constants.SOCKET_YAML);
      yml = fs.safeReadFileSync(ymlPath);
    }
    if (typeof yml === 'string') {
      try {
        return {
          ok: true,
          data: {
            path: ymlPath,
            parsed: vendor.configExports.parseSocketConfig(yml)
          }
        };
      } catch (e) {
        require$$9.debugFn('error', `Failed to parse config file: ${ymlPath}`);
        require$$9.debugDir('error', e);
        return {
          ok: false,
          message: `Found file but was unable to parse ${ymlPath}`,
          cause: getErrorCause(e)
        };
      }
    }
    prevDir = dir;
    dir = path.join(dir, '..');
  }
  return {
    ok: true,
    data: undefined
  };
}
function getConfigValue(key) {
  const localConfig = getConfigValues();
  const keyResult = normalizeConfigKey(key);
  if (!keyResult.ok) {
    return keyResult;
  }
  return {
    ok: true,
    data: localConfig[keyResult.data]
  };
}

// This version squashes errors, returning undefined instead.
// Should be used when we can reasonably predict the call can't fail.
function getConfigValueOrUndef(key) {
  const localConfig = getConfigValues();
  const keyResult = normalizeConfigKey(key);
  if (!keyResult.ok) {
    return undefined;
  }
  return localConfig[keyResult.data];
}

// Ensure export because dist/utils.js is required in src/constants.mts.
// eslint-disable-next-line n/exports-style
if (typeof exports === 'object' && exports !== null) {
  // eslint-disable-next-line n/exports-style
  exports.getConfigValueOrUndef = getConfigValueOrUndef;
}
function getSupportedConfigEntries() {
  return [...supportedConfigEntries];
}
function getSupportedConfigKeys() {
  return [...supportedConfigKeys];
}
function isConfigFromFlag() {
  return _configFromFlag;
}
function isSensitiveConfigKey(key) {
  return sensitiveConfigKeyLookup.has(key);
}
function isSupportedConfigKey(key) {
  return supportedConfig.has(key);
}
let _cachedConfig;
// When using --config or SOCKET_CLI_CONFIG, do not persist the config.
let _configFromFlag = false;
function overrideCachedConfig(jsonConfig) {
  require$$9.debugFn('notice', 'override: full config (not stored)');
  let config;
  try {
    config = JSON.parse(String(jsonConfig));
    if (!config || typeof config !== 'object') {
      // `null` is valid json, so are primitive values.
      // They're not valid config objects :)
      return {
        ok: false,
        message: 'Could not parse Config as JSON',
        cause: "Could not JSON parse the config override. Make sure it's a proper JSON object (double-quoted keys and strings, no unquoted `undefined`) and try again."
      };
    }
  } catch {
    // Force set an empty config to prevent accidentally using system settings.
    _cachedConfig = {};
    _configFromFlag = true;
    return {
      ok: false,
      message: 'Could not parse Config as JSON',
      cause: "Could not JSON parse the config override. Make sure it's a proper JSON object (double-quoted keys and strings, no unquoted `undefined`) and try again."
    };
  }

  // @ts-ignore Override an illegal object.
  _cachedConfig = config;
  _configFromFlag = true;

  // Normalize apiKey to apiToken.
  if (_cachedConfig['apiKey']) {
    if (_cachedConfig['apiToken']) {
      logger.logger.warn('Note: The config override had both apiToken and apiKey. Using the apiToken value. Remove the apiKey to get rid of this message.');
    }
    _cachedConfig['apiToken'] = _cachedConfig['apiKey'];
    delete _cachedConfig['apiKey'];
  }
  return {
    ok: true,
    data: undefined
  };
}
function overrideConfigApiToken(apiToken) {
  require$$9.debugFn('notice', 'override: Socket API token (not stored)');
  // Set token to the local cached config and mark it read-only so it doesn't persist.
  _cachedConfig = {
    ...vendor.configExports,
    ...(apiToken === undefined ? {} : {
      apiToken: String(apiToken)
    })
  };
  _configFromFlag = true;
}
let _pendingSave = false;
function updateConfigValue(configKey, value) {
  const localConfig = getConfigValues();
  const keyResult = normalizeConfigKey(configKey);
  if (!keyResult.ok) {
    return keyResult;
  }
  const key = keyResult.data;
  // Implicitly deleting when serializing.
  let wasDeleted = value === undefined;
  if (key === 'skipAskToPersistDefaultOrg') {
    if (value === 'true' || value === 'false') {
      localConfig['skipAskToPersistDefaultOrg'] = value === 'true';
    } else {
      delete localConfig['skipAskToPersistDefaultOrg'];
      wasDeleted = true;
    }
  } else {
    if (value === 'undefined' || value === 'true' || value === 'false') {
      logger.logger.warn(`Note: The value is set to "${value}", as a string (!). Use \`socket config unset\` to reset a key.`);
    }
    localConfig[key] = value;
  }
  if (_configFromFlag) {
    return {
      ok: true,
      message: `Config key '${key}' was ${wasDeleted ? 'deleted' : `updated`}`,
      data: 'Change applied but not persisted; current config is overridden through env var or flag'
    };
  }
  if (!_pendingSave) {
    _pendingSave = true;
    process.nextTick(() => {
      _pendingSave = false;
      const {
        socketAppDataPath
      } = constants.default;
      if (socketAppDataPath) {
        fs$1.writeFileSync(socketAppDataPath, Buffer.from(JSON.stringify(localConfig)).toString('base64'));
      }
    });
  }
  return {
    ok: true,
    message: `Config key '${key}' was ${wasDeleted ? 'deleted' : `updated`}`,
    data: undefined
  };
}

/**
 * Requirements configuration utilities for Socket CLI.
 * Manages API permissions and quota requirements for commands.
 *
 * Key Functions:
 * - getRequirements: Load requirements configuration
 * - getRequirementsKey: Convert command path to requirements key
 *
 * Configuration:
 * - Loads from requirements.json
 * - Maps command paths to permission requirements
 * - Used for permission validation and help text
 */

const require$3 = require$$5.createRequire((typeof document === 'undefined' ? require$$0.pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('utils.js', document.baseURI).href)));
let _requirements;
function getRequirements() {
  if (_requirements === undefined) {
    _requirements = /*@__PURE__*/require$3(path.join(constants.default.rootPath, 'requirements.json'));
  }
  return _requirements;
}

/**
 * Convert command path to requirements key.
 */
function getRequirementsKey(cmdPath) {
  return cmdPath.replace(/^socket[: ]/, '').replace(/ +/g, ':');
}

/**
 * Socket SDK utilities for Socket CLI.
 * Manages SDK initialization and configuration for API communication.
 *
 * Authentication:
 * - Interactive password prompt for missing tokens
 * - Supports environment variable (SOCKET_CLI_API_TOKEN)
 * - Validates token format and presence
 *
 * Proxy Support:
 * - Automatic proxy agent selection
 * - HTTP/HTTPS proxy configuration
 * - Respects SOCKET_CLI_API_PROXY environment variable
 *
 * SDK Setup:
 * - createSocketSdk: Create configured SDK instance
 * - getDefaultApiToken: Retrieve API token from config/env
 * - getDefaultProxyUrl: Retrieve proxy URL from config/env
 * - getPublicApiToken: Get public API token constant
 * - setupSdk: Initialize Socket SDK with authentication
 *
 * User Agent:
 * - Automatic user agent generation from package.json
 * - Includes CLI version and platform information
 */

const TOKEN_PREFIX = 'sktsec_';
const TOKEN_PREFIX_LENGTH = TOKEN_PREFIX.length;
const TOKEN_VISIBLE_LENGTH = 5;

// The Socket API server that should be used for operations.
function getDefaultApiBaseUrl$1() {
  const baseUrl = constants.default.ENV.SOCKET_CLI_API_BASE_URL || getConfigValueOrUndef(constants.CONFIG_KEY_API_BASE_URL);
  return require$$13.isUrl(baseUrl) ? baseUrl : undefined;
}

// The Socket API server that should be used for operations.
function getDefaultProxyUrl() {
  const apiProxy = constants.default.ENV.SOCKET_CLI_API_PROXY || getConfigValueOrUndef(constants.CONFIG_KEY_API_PROXY);
  return require$$13.isUrl(apiProxy) ? apiProxy : undefined;
}

// This Socket API token should be stored globally for the duration of the CLI execution.
let _defaultToken;
function getDefaultApiToken() {
  if (constants.default.ENV.SOCKET_CLI_NO_API_TOKEN) {
    _defaultToken = undefined;
    return _defaultToken;
  }
  const key = constants.default.ENV.SOCKET_CLI_API_TOKEN || getConfigValueOrUndef(constants.CONFIG_KEY_API_TOKEN) || _defaultToken;
  _defaultToken = strings.isNonEmptyString(key) ? key : undefined;
  return _defaultToken;
}
function getPublicApiToken() {
  return getDefaultApiToken() || constants.default.ENV.SOCKET_CLI_API_TOKEN || constants.default.SOCKET_PUBLIC_API_TOKEN;
}
function getVisibleTokenPrefix() {
  const apiToken = getDefaultApiToken();
  return apiToken ? apiToken.slice(TOKEN_PREFIX_LENGTH, TOKEN_PREFIX_LENGTH + TOKEN_VISIBLE_LENGTH) : '';
}
function hasDefaultApiToken() {
  return !!getDefaultApiToken();
}
async function setupSdk(options) {
  const opts = {
    __proto__: null,
    ...options
  };
  let {
    apiToken = getDefaultApiToken()
  } = opts;
  if (typeof apiToken !== 'string' && vendor.isInteractiveExports()) {
    apiToken = await prompts.password({
      message: 'Enter your Socket.dev API token (not saved, use socket login to persist)'
    });
    _defaultToken = apiToken;
  }
  if (!apiToken) {
    return {
      ok: false,
      message: 'Auth Error',
      cause: 'You need to provide an API token. Run `socket login` first.'
    };
  }
  let {
    apiProxy
  } = opts;
  if (!require$$13.isUrl(apiProxy)) {
    apiProxy = getDefaultProxyUrl();
  }
  const {
    apiBaseUrl = getDefaultApiBaseUrl$1()
  } = opts;

  // Usage of HttpProxyAgent vs. HttpsProxyAgent based on the chart at:
  // https://github.com/delvedor/hpagent?tab=readme-ov-file#usage
  const ProxyAgent = apiBaseUrl?.startsWith('http:') ? vendor.HttpProxyAgent : vendor.HttpsProxyAgent;
  return {
    ok: true,
    data: new vendor.distExports.SocketSdk(apiToken, {
      ...(apiProxy ? {
        agent: new ProxyAgent({
          proxy: apiProxy
        })
      } : {}),
      ...(apiBaseUrl ? {
        baseUrl: apiBaseUrl
      } : {}),
      timeout: constants.default.ENV.SOCKET_CLI_API_TIMEOUT,
      userAgent: vendor.distExports.createUserAgentFromPkgJson({
        name: constants.default.ENV.INLINED_SOCKET_CLI_NAME,
        version: constants.default.ENV.INLINED_SOCKET_CLI_VERSION,
        homepage: constants.default.ENV.INLINED_SOCKET_CLI_HOMEPAGE
      })
    })
  };
}

/**
 * API utilities for Socket CLI.
 * Provides consistent API communication with error handling and permissions management.
 *
 * Key Functions:
 * - getDefaultApiBaseUrl: Get configured API endpoint
 * - getErrorMessageForHttpStatusCode: User-friendly HTTP error messages
 * - handleApiCall: Execute Socket SDK API calls with error handling
 * - handleApiCallNoSpinner: Execute API calls without UI spinner
 * - queryApi: Execute raw API queries with text response
 *
 * Error Handling:
 * - Automatic permission requirement logging for 403 errors
 * - Detailed error messages for common HTTP status codes
 * - Integration with debug helpers for API response logging
 *
 * Configuration:
 * - Respects SOCKET_CLI_API_BASE_URL environment variable
 * - Falls back to configured apiBaseUrl or default API_V0_URL
 */

const NO_ERROR_MESSAGE = 'No error message returned';
/**
 * Get command requirements from requirements.json based on command path.
 */
function getCommandRequirements(cmdPath) {
  if (!cmdPath) {
    return undefined;
  }
  const requirements = getRequirements();
  const key = getRequirementsKey(cmdPath);
  return requirements.api[key] || undefined;
}

/**
 * Log required permissions for a command when encountering 403 errors.
 */
function logPermissionsFor403(cmdPath) {
  const requirements = getCommandRequirements(cmdPath);
  if (!requirements?.permissions?.length) {
    return;
  }
  logger.logger.error('This command requires the following API permissions:');
  for (const permission of requirements.permissions) {
    logger.logger.error(`  - ${permission}`);
  }
  logger.logger.error('Please ensure your API token has the required permissions.');
}

// The Socket API server that should be used for operations.
function getDefaultApiBaseUrl() {
  const baseUrl = constants.default.ENV.SOCKET_CLI_API_BASE_URL || getConfigValueOrUndef(constants.CONFIG_KEY_API_BASE_URL);
  if (strings.isNonEmptyString(baseUrl)) {
    return baseUrl;
  }
  const API_V0_URL = constants.default.API_V0_URL;
  return API_V0_URL;
}

/**
 * Get user-friendly error message for HTTP status codes.
 */
async function getErrorMessageForHttpStatusCode(code) {
  if (code === constants.HTTP_STATUS_BAD_REQUEST) {
    return 'One of the options passed might be incorrect';
  }
  if (code === constants.HTTP_STATUS_FORBIDDEN || code === constants.HTTP_STATUS_UNAUTHORIZED) {
    return 'Your Socket API token may not have the required permissions for this command or you might be trying to access (data from) an organization that is not linked to the API token you are logged in with';
  }
  if (code === constants.HTTP_STATUS_NOT_FOUND) {
    return 'The requested Socket API endpoint was not found (404) or there was no result for the requested parameters. If unexpected, this could be a temporary problem caused by an incident or a bug in the CLI. If the problem persists please let us know.';
  }
  if (code === constants.HTTP_STATUS_INTERNAL_SERVER_ERROR) {
    return 'There was an unknown server side problem with your request. This ought to be temporary. Please let us know if this problem persists.';
  }
  return `Server responded with status code ${code}`;
}
/**
 * Handle Socket SDK API calls with error handling and permission logging.
 */
async function handleApiCall(value, options) {
  const {
    commandPath,
    description,
    spinner
  } = {
    __proto__: null,
    ...options
  };
  if (description) {
    spinner?.start(`Requesting ${description} from API...`);
  } else {
    spinner?.start();
  }
  let sdkResult;
  try {
    sdkResult = await value;
    spinner?.stop();
    if (description) {
      const message = `Received Socket API response (after requesting ${description}).`;
      if (sdkResult.success) {
        logger.logger.success(message);
      } else {
        logger.logger.info(message);
      }
    }
  } catch (e) {
    spinner?.stop();
    const socketSdkErrorResult = {
      ok: false,
      message: 'Socket API error',
      cause: vendor.messageWithCauses(e)
    };
    if (description) {
      logger.logger.fail(`An error was thrown while requesting ${description}`);
      debugApiResponse(description, undefined, e);
    } else {
      debugApiResponse('Socket API', undefined, e);
    }
    require$$9.debugDir('inspect', {
      socketSdkErrorResult
    });
    return socketSdkErrorResult;
  }

  // Note: TS can't narrow down the type of result due to generics.
  if (sdkResult.success === false) {
    const endpoint = description || 'Socket API';
    debugApiResponse(endpoint, sdkResult.status);
    require$$9.debugDir('inspect', {
      sdkResult
    });
    const errCResult = sdkResult;
    const errStr = errCResult.error ? String(errCResult.error).trim() : '';
    const message = errStr || NO_ERROR_MESSAGE;
    const reason = errCResult.cause || NO_ERROR_MESSAGE;
    const cause = reason && message !== reason ? `${message} (reason: ${reason})` : message;
    const socketSdkErrorResult = {
      ok: false,
      message: 'Socket API error',
      cause,
      data: {
        code: sdkResult.status
      }
    };

    // Log required permissions for 403 errors when in a command context.
    if (commandPath && sdkResult.status === 403) {
      logPermissionsFor403(commandPath);
    }
    return socketSdkErrorResult;
  }
  const socketSdkSuccessResult = {
    ok: true,
    data: sdkResult.data
  };
  return socketSdkSuccessResult;
}
async function handleApiCallNoSpinner(value, description) {
  let sdkResult;
  try {
    sdkResult = await value;
  } catch (e) {
    require$$9.debugFn('error', `API request failed: ${description}`);
    require$$9.debugDir('error', e);
    const errStr = e ? String(e).trim() : '';
    const message = 'Socket API error';
    const rawCause = errStr || NO_ERROR_MESSAGE;
    const cause = message !== rawCause ? rawCause : '';
    return {
      ok: false,
      message,
      ...(cause ? {
        cause
      } : {})
    };
  }

  // Note: TS can't narrow down the type of result due to generics
  if (sdkResult.success === false) {
    require$$9.debugFn('error', `fail: ${description} bad response`);
    require$$9.debugDir('inspect', {
      sdkResult
    });
    const sdkErrorResult = sdkResult;
    const errStr = sdkErrorResult.error ? String(sdkErrorResult.error).trim() : '';
    const message = errStr || NO_ERROR_MESSAGE;
    const reason = sdkErrorResult.cause || NO_ERROR_MESSAGE;
    const cause = reason && message !== reason ? `${message} (reason: ${reason})` : message;
    return {
      ok: false,
      message: 'Socket API error',
      cause,
      data: {
        code: sdkResult.status
      }
    };
  } else {
    const sdkSuccessResult = sdkResult;
    return {
      ok: true,
      data: sdkSuccessResult.data
    };
  }
}
async function queryApi(path, apiToken) {
  const baseUrl = getDefaultApiBaseUrl();
  if (!baseUrl) {
    throw new Error('Socket API base URL is not configured.');
  }
  return await fetch(`${baseUrl}${baseUrl.endsWith('/') ? '' : '/'}${path}`, {
    method: 'GET',
    headers: {
      Authorization: `Basic ${btoa(`${apiToken}:`)}`
    }
  });
}

/**
 * Query Socket API endpoint and return text response with error handling.
 */
async function queryApiSafeText(path, description, commandPath) {
  const apiToken = getDefaultApiToken();
  if (!apiToken) {
    return {
      ok: false,
      message: 'Authentication Error',
      cause: 'User must be authenticated to run this command. Run `socket login` and enter your Socket API token.'
    };
  }
  const {
    spinner
  } = constants.default;
  if (description) {
    spinner.start(`Requesting ${description} from API...`);
  }
  let result;
  try {
    result = await queryApi(path, apiToken);
    if (description) {
      spinner.successAndStop(`Received Socket API response (after requesting ${description}).`);
    }
  } catch (e) {
    if (description) {
      spinner.failAndStop(`An error was thrown while requesting ${description}.`);
    }
    require$$9.debugFn('error', 'Query API request failed');
    require$$9.debugDir('error', e);
    const errStr = e ? String(e).trim() : '';
    const message = 'API request failed';
    const rawCause = errStr || NO_ERROR_MESSAGE;
    const cause = message !== rawCause ? rawCause : '';
    return {
      ok: false,
      message,
      ...(cause ? {
        cause
      } : {})
    };
  }
  if (!result.ok) {
    const {
      status
    } = result;
    return {
      ok: false,
      message: 'Socket API error',
      cause: `${result.statusText} (reason: ${await getErrorMessageForHttpStatusCode(status)})`,
      data: {
        code: status
      }
    };
  }
  try {
    const data = await result.text();
    return {
      ok: true,
      data
    };
  } catch (e) {
    require$$9.debugFn('error', 'Failed to read API response text');
    require$$9.debugDir('error', e);
    return {
      ok: false,
      message: 'API request failed',
      cause: 'Unexpected error reading response text'
    };
  }
}

/**
 * Query Socket API endpoint and return parsed JSON response.
 */
async function queryApiSafeJson(path, description = '') {
  const result = await queryApiSafeText(path, description);
  if (!result.ok) {
    return result;
  }
  try {
    return {
      ok: true,
      data: JSON.parse(result.data)
    };
  } catch (e) {
    return {
      ok: false,
      message: 'Server returned invalid JSON',
      cause: `Please report this. JSON.parse threw an error over the following response: \`${(result.data?.slice?.(0, 100) || constants.EMPTY_VALUE).trim() + (result.data?.length > 100 ? '...' : '')}\``
    };
  }
}
/**
 * Send POST/PUT request to Socket API with JSON response handling.
 */
async function sendApiRequest(path, options) {
  const apiToken = getDefaultApiToken();
  if (!apiToken) {
    return {
      ok: false,
      message: 'Authentication Error',
      cause: 'User must be authenticated to run this command. To log in, run the command `socket login` and enter your Socket API token.'
    };
  }
  const baseUrl = getDefaultApiBaseUrl();
  if (!baseUrl) {
    return {
      ok: false,
      message: 'Configuration Error',
      cause: 'Socket API endpoint is not configured. Please check your environment configuration.'
    };
  }
  const {
    body,
    commandPath,
    description,
    method
  } = {
    __proto__: null,
    ...options
  };
  const {
    spinner
  } = constants.default;
  if (description) {
    spinner.start(`Requesting ${description} from API...`);
  }
  let result;
  try {
    const fetchOptions = {
      method,
      headers: {
        Authorization: `Basic ${btoa(`${apiToken}:`)}`,
        'Content-Type': 'application/json'
      },
      ...(body ? {
        body: JSON.stringify(body)
      } : {})
    };
    result = await fetch(`${baseUrl}${baseUrl.endsWith('/') ? '' : '/'}${path}`, fetchOptions);
    if (description) {
      spinner.successAndStop(`Received Socket API response (after requesting ${description}).`);
    }
  } catch (e) {
    if (description) {
      spinner.failAndStop(`An error was thrown while requesting ${description}.`);
    }
    require$$9.debugFn('error', `API ${method} request failed`);
    require$$9.debugDir('error', e);
    const errStr = e ? String(e).trim() : '';
    const message = 'API request failed';
    const rawCause = errStr || NO_ERROR_MESSAGE;
    const cause = message !== rawCause ? rawCause : '';
    return {
      ok: false,
      message,
      ...(cause ? {
        cause
      } : {})
    };
  }
  if (!result.ok) {
    const {
      status
    } = result;
    // Log required permissions for 403 errors when in a command context.
    if (commandPath && status === 403) {
      logPermissionsFor403(commandPath);
    }
    return {
      ok: false,
      message: 'Socket API error',
      cause: `${result.statusText} (reason: ${await getErrorMessageForHttpStatusCode(status)})`,
      data: {
        code: status
      }
    };
  }
  try {
    const data = await result.json();
    return {
      ok: true,
      data: data
    };
  } catch (e) {
    require$$9.debugFn('error', 'Failed to parse API response JSON');
    require$$9.debugDir('error', e);
    return {
      ok: false,
      message: 'API request failed',
      cause: 'Unexpected error parsing response JSON'
    };
  }
}

function failMsgWithBadge(badge, message) {
  const prefix = vendor.yoctocolorsCjsExports.bgRedBright(vendor.yoctocolorsCjsExports.bold(vendor.yoctocolorsCjsExports.red(` ${badge}${message ? ': ' : ''}`)));
  const postfix = message ? ` ${vendor.yoctocolorsCjsExports.bold(message)}` : '';
  return `${prefix}${postfix}`;
}

/**
 * Markdown utilities for Socket CLI.
 * Generates formatted markdown output for reports and documentation.
 *
 * Key Functions:
 * - mdTableStringNumber: Create markdown table with string keys and number values
 *
 * Table Features:
 * - Auto-sizing columns based on content
 * - Proper alignment for headers and data
 * - Clean markdown-compliant formatting
 *
 * Usage:
 * - Analytics reports
 * - Scan result tables
 * - Statistical summaries
 */

function mdTableStringNumber(title1, title2, obj) {
  // | Date        | Counts |
  // | ----------- | ------ |
  // | Header      | 201464 |
  // | Paragraph   |     18 |
  let mw1 = title1.length;
  let mw2 = title2.length;
  for (const {
    0: key,
    1: value
  } of Object.entries(obj)) {
    mw1 = Math.max(mw1, key.length);
    mw2 = Math.max(mw2, String(value ?? '').length);
  }
  const lines = [];
  lines.push(`| ${title1.padEnd(mw1, ' ')} | ${title2.padEnd(mw2)} |`);
  lines.push(`| ${'-'.repeat(mw1)} | ${'-'.repeat(mw2)} |`);
  for (const {
    0: key,
    1: value
  } of Object.entries(obj)) {
    lines.push(`| ${key.padEnd(mw1, ' ')} | ${String(value ?? '').padStart(mw2, ' ')} |`);
  }
  lines.push(`| ${'-'.repeat(mw1)} | ${'-'.repeat(mw2)} |`);
  return lines.join('\n');
}
function mdTable(logs,
// This is saying "an array of strings and the strings are a valid key of elements of T"
// In turn, T is defined above as the audit log event type from our OpenAPI docs.
cols, titles = cols) {
  // Max col width required to fit all data in that column
  const cws = cols.map(col => col.length);
  for (const log of logs) {
    for (let i = 0, {
        length
      } = cols; i < length; i += 1) {
      // @ts-ignore
      const val = log[cols[i] ?? ''] ?? '';
      cws[i] = Math.max(cws[i] ?? 0, String(val).length, (titles[i] || '').length);
    }
  }
  let div = '|';
  for (const cw of cws) {
    div += ' ' + '-'.repeat(cw) + ' |';
  }
  let header = '|';
  for (let i = 0, {
      length
    } = titles; i < length; i += 1) {
    header += ' ' + String(titles[i]).padEnd(cws[i] ?? 0, ' ') + ' |';
  }
  let body = '';
  for (const log of logs) {
    body += '|';
    for (let i = 0, {
        length
      } = cols; i < length; i += 1) {
      // @ts-ignore
      const val = log[cols[i] ?? ''] ?? '';
      body += ' ' + String(val).padEnd(cws[i] ?? 0, ' ') + ' |';
    }
    body += '\n';
  }
  return [div, header, div, body.trim(), div].filter(s => s.trim()).join('\n');
}
function mdTableOfPairs(arr,
// This is saying "an array of strings and the strings are a valid key of elements of T"
// In turn, T is defined above as the audit log event type from our OpenAPI docs.
cols) {
  // Max col width required to fit all data in that column
  const cws = cols.map(col => col.length);
  for (const [key, val] of arr) {
    cws[0] = Math.max(cws[0] ?? 0, String(key).length);
    cws[1] = Math.max(cws[1] ?? 0, String(val ?? '').length);
  }
  let div = '|';
  for (const cw of cws) {
    div += ' ' + '-'.repeat(cw) + ' |';
  }
  let header = '|';
  for (let i = 0, {
      length
    } = cols; i < length; i += 1) {
    header += ' ' + String(cols[i]).padEnd(cws[i] ?? 0, ' ') + ' |';
  }
  let body = '';
  for (const [key, val] of arr) {
    body += '|';
    body += ' ' + String(key).padEnd(cws[0] ?? 0, ' ') + ' |';
    body += ' ' + String(val ?? '').padEnd(cws[1] ?? 0, ' ') + ' |';
    body += '\n';
  }
  return [div, header, div, body.trim(), div].filter(s => s.trim()).join('\n');
}

// Serialize the final result object before printing it
// All commands that support the --json flag should call this before printing
function serializeResultJson(data) {
  if (!require$$11.isObject(data)) {
    process.exitCode = 1;
    require$$9.debugFn('inspect', {
      data
    });

    // We should not allow the JSON value to be "null", or a boolean/number/string,
    // even if they are valid "json".
    return `${JSON.stringify({
      ok: false,
      message: 'Unable to serialize JSON',
      cause: 'There was a problem converting the data set to JSON. The JSON was not an object. Please try again without --json'
    }).trim()}\n`;
  }
  try {
    return `${JSON.stringify(data, null, 2).trim()}\n`;
  } catch (e) {
    process.exitCode = 1;
    const message = 'There was a problem converting the data set to JSON. Please try again without --json';
    logger.logger.fail(message);
    require$$9.debugFn('error', 'JSON serialization failed');
    require$$9.debugDir('error', e);

    // This could be caused by circular references, which is an "us" problem.
    return `${JSON.stringify({
      ok: false,
      message: 'Unable to serialize JSON',
      cause: message
    }).trim()}\n`;
  }
}

/**
 * Creates a terminal link to a local file.
 * @param filePath The file path to link to
 * @param text Optional display text (defaults to the file path itself)
 * @returns A terminal link to the file
 */
function fileLink(filePath, text) {
  const absolutePath = path.isAbsolute(filePath) ? filePath : path.resolve(filePath);
  return vendor.terminalLinkExports(filePath, `file://${absolutePath}`);
}

/**
 * Creates a terminal link to an email address.
 * @param email The email address
 * @param text Optional display text (defaults to the email address itself)
 * @returns A terminal link to compose an email
 */
function mailtoLink(email, text) {
  return vendor.terminalLinkExports(email, `mailto:${email}`);
}

/**
 * Creates a terminal link to the Socket.dev dashboard.
 * @param path The path within the dashboard (e.g., '/org/YOURORG/alerts')
 * @param text Optional display text
 * @returns A terminal link to the Socket.dev dashboard URL
 */
function socketDashboardLink(dashPath, text) {
  const url = `https://socket.dev/dashboard${dashPath.startsWith('/') ? dashPath : `/${dashPath}`}`;
  return vendor.terminalLinkExports(text, url);
}

/**
 * Creates a terminal link to the Socket.dev website.
 * @param text Display text for the link (defaults to 'Socket.dev')
 * @param urlPath Optional path to append to the base URL (e.g., '/pricing')
 * @returns A terminal link to Socket.dev
 */
function socketDevLink(text, urlPath) {
  return vendor.terminalLinkExports(text, `${constants.SOCKET_WEBSITE_URL}${urlPath}`);
}

/**
 * Creates a terminal link to Socket.dev documentation.
 * @param docPath The documentation path (e.g., '/docs/api-keys')
 * @param text Optional display text
 * @returns A terminal link to the Socket.dev documentation
 */
function socketDocsLink(docPath, text) {
  const url = `https://docs.socket.dev${docPath.startsWith('/') ? docPath : `/${docPath}`}`;
  return vendor.terminalLinkExports(text ?? url, url);
}

/**
 * Creates a terminal link to Socket.dev package page.
 * @param ecosystem The package ecosystem (e.g., 'npm')
 * @param packageName The package name
 * @param version Optional package version or path (e.g., 'files/1.0.0/CHANGELOG.md')
 * @param text Optional display text
 * @returns A terminal link to the Socket.dev package page
 */
function socketPackageLink(ecosystem, packageName, version, text) {
  let url;
  if (version) {
    // Check if version contains a path like 'files/1.0.0/CHANGELOG.md'.
    if (version.includes('/')) {
      url = `https://socket.dev/${ecosystem}/package/${packageName}/${version}`;
    } else {
      url = `https://socket.dev/${ecosystem}/package/${packageName}/overview/${version}`;
    }
  } else {
    url = `https://socket.dev/${ecosystem}/package/${packageName}`;
  }
  return vendor.terminalLinkExports(text ?? url, url);
}

/**
 * Creates a terminal link to a web URL.
 * @param url The web URL to link to
 * @param text Optional display text (defaults to the URL itself)
 * @returns A terminal link to the URL
 */
function webLink(url, text) {
  return vendor.terminalLinkExports(text ?? url, url);
}

function checkCommandInput(outputKind, ...checks) {
  if (checks.every(d => d.test)) {
    return true;
  }
  const msg = ['Please review the input requirements and try again', ''];
  for (const d of checks) {
    // If nook, then ignore when test is ok
    if (d.nook && d.test) {
      continue;
    }
    const lines = d.message.split('\n');
    const {
      length: lineCount
    } = lines;
    if (!lineCount) {
      continue;
    }
    // If the message has newlines then format the first line with the input
    // expectation and the rest indented below it.
    const logSymbol = d.test ? logger.LOG_SYMBOLS.success : logger.LOG_SYMBOLS.fail;
    const reason = d.test ? d.pass : d.fail;
    let listItem = `  ${logSymbol} ${lines[0]}`;
    if (reason) {
      const styledReason = d.test ? vendor.yoctocolorsCjsExports.green(reason) : vendor.yoctocolorsCjsExports.red(reason);
      listItem += ` (${styledReason})`;
    }
    msg.push(listItem);
    if (lineCount > 1) {
      msg.push(...lines.slice(1).map(str => `    ${str}`));
    }
  }

  // Use exit status of 2 to indicate incorrect usage, generally invalid
  // options or missing arguments.
  // https://www.gnu.org/software/bash/manual/html_node/Exit-Status.html
  process.exitCode = 2;
  if (outputKind === 'json') {
    logger.logger.log(serializeResultJson({
      ok: false,
      message: 'Input error',
      data: strings.stripAnsi(msg.join('\n'))
    }));
  } else {
    logger.logger.fail(failMsgWithBadge('Input error', msg.join('\n')));
  }
  return false;
}

/**
 * Output format detection utilities for Socket CLI.
 * Determines output format based on command flags.
 *
 * Key Functions:
 * - getOutputKind: Determine output format from flags
 *
 * Supported Formats:
 * - JSON: Machine-readable JSON output
 * - Markdown: Formatted markdown for reports
 * - Text: Plain text for terminal display
 *
 * Usage:
 * - Processes --json and --markdown flags
 * - Returns appropriate output format constant
 * - Defaults to text format for terminal display
 */

function getOutputKind(json, markdown) {
  if (json) {
    return constants.OUTPUT_JSON;
  }
  if (markdown) {
    return constants.OUTPUT_MARKDOWN;
  }
  return constants.OUTPUT_TEXT;
}

/**
 * String manipulation utilities for Socket CLI.
 * Provides common string transformations and formatting.
 *
 * Key Functions:
 * - camelToKebab: Convert camelCase to kebab-case
 *
 * Usage:
 * - Command name transformations
 * - Flag name conversions
 * - Consistent string formatting
 */

function camelToKebab(str) {
  return str === '' ? '' : str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}

/**
 * Output formatting utilities for Socket CLI.
 * Provides consistent formatting for help text and command output.
 *
 * Key Functions:
 * - getFlagApiRequirementsOutput: Format API requirements for flags
 * - getHelpListOutput: Format help text lists with descriptions
 * - getFlagsHelpOutput: Generate formatted help for command flags
 *
 * Formatting Features:
 * - Automatic indentation and alignment
 * - Flag description formatting
 * - Requirements and permissions display
 * - Hidden flag filtering
 *
 * Usage:
 * - Used by command help systems
 * - Provides consistent terminal output formatting
 * - Handles kebab-case conversion for flags
 */

function getFlagApiRequirementsOutput(cmdPath, options) {
  const {
    indent = 6
  } = {
    __proto__: null,
    ...options
  };
  const key = getRequirementsKey(cmdPath);
  const requirements = getRequirements();
  const data = requirements.api[key];
  let result = '';
  if (data) {
    const quota = data?.quota;
    const rawPerms = data?.permissions;
    const padding = ''.padEnd(indent);
    const lines = [];
    if (Number.isFinite(quota) && quota > 0) {
      lines.push(`${padding}- Quota: ${quota} ${words.pluralize('unit', quota)}`);
    }
    if (Array.isArray(rawPerms) && rawPerms.length) {
      const perms = rawPerms.slice().sort(sorts.naturalCompare);
      lines.push(`${padding}- Permissions: ${arrays.joinAnd(perms)}`);
    }
    result += lines.join('\n');
  }
  return result.trim() || '(none)';
}
function getFlagListOutput(list, options) {
  const {
    keyPrefix = '--'
  } = {
    __proto__: null,
    ...options
  };
  return getHelpListOutput({
    ...list
  }, {
    ...options,
    keyPrefix
  });
}
function getHelpListOutput(list, options) {
  const {
    indent = 6,
    keyPrefix = '',
    padName = 20
  } = {
    __proto__: null,
    ...options
  };
  let result = '';
  const names = Object.keys(list).sort(sorts.naturalCompare);
  for (const name of names) {
    const entry = list[name];
    const entryIsObj = require$$11.isObject(entry);
    if (entryIsObj && 'hidden' in entry && entry?.hidden) {
      continue;
    }
    const printedName = `${keyPrefix}${camelToKebab(name)}`;
    const preDescription = `${''.padEnd(indent)}${printedName.padEnd(Math.max(printedName.length + 2, padName))}`;
    result += preDescription;
    const description = entryIsObj ? entry.description : String(entry);
    if (description) {
      result += strings.indentString(description, preDescription.length).trimStart();
    }
    result += '\n';
  }
  return result.trim() || '(none)';
}

/**
 * Path tildification utilities for Socket CLI.
 * Abbreviates home directory paths with tilde notation.
 *
 * Key Functions:
 * - tildify: Replace home directory with ~ in paths
 *
 * Usage:
 * - Shortens absolute paths for display
 * - Converts /Users/name/... to ~/...
 * - Common Unix convention for home directory
 */

function tildify(cwd) {
  return cwd.replace(new RegExp(`^${regexps.escapeRegExp(constants.default.homePath)}(?:${path.sep}|$)`, 'i'), '~/');
}

// Property names are picked such that the name is at the top when the props
// get ordered by alphabet while flags is near the bottom and the help text
// at the bottom, because they tend ot occupy the most lines of code.

const HELP_INDENT = 2;
const HELP_PAD_NAME = 28;

/**
 * Format a command description for help output.
 */
function description(command) {
  const description = command?.description;
  const str = typeof description === 'string' ? description : String(description);
  return strings.indentString(str, HELP_PAD_NAME).trimStart();
}

/**
 * Find the best matching command name for a typo.
 */
function findBestCommandMatch(input, subcommands, aliases) {
  let bestMatch = null;
  let bestScore = Infinity;
  const allCommands = [...Object.keys(subcommands), ...Object.keys(aliases)];
  for (const command of allCommands) {
    const distance = levenshteinDistance(input.toLowerCase(), command.toLowerCase());
    const maxLength = Math.max(input.length, command.length);
    // Only suggest if the similarity is reasonable (more than 50% similar).
    if (distance < maxLength * 0.5 && distance < bestScore) {
      bestScore = distance;
      bestMatch = command;
    }
  }
  return bestMatch;
}

/**
 * Determine the origin of the API token.
 */
function getTokenOrigin() {
  if (constants.default.ENV.SOCKET_CLI_NO_API_TOKEN) {
    return '';
  }
  if (constants.default.ENV.SOCKET_CLI_API_TOKEN) {
    return '(env)';
  }
  const configToken = getConfigValueOrUndef(constants.CONFIG_KEY_API_TOKEN);
  if (configToken) {
    return isConfigFromFlag() ? '(--config flag)' : '(config)';
  }
  return '';
}

/**
 * Generate the ASCII banner header for Socket CLI commands.
 */
function getAsciiHeader(command, orgFlag, compactMode = false) {
  // Note: In tests we return <redacted> because otherwise snapshots will fail.
  const {
    REDACTED
  } = constants.default;
  const redacting = constants.default.ENV.VITEST;

  // Version display: show hash in debug mode, otherwise show semantic version.
  const fullVersion = constants.default.ENV.INLINED_SOCKET_CLI_VERSION;
  const versionHash = constants.default.ENV.INLINED_SOCKET_CLI_VERSION_HASH;
  const cliVersion = redacting ? REDACTED : require$$9.isDebug() ? versionHash : `v${fullVersion}`;
  const nodeVersion = redacting ? REDACTED : process.version;
  const showNodeVersion = !redacting && require$$9.isDebug();
  const defaultOrg = getConfigValueOrUndef(constants.CONFIG_KEY_DEFAULT_ORG);
  const configFromFlagDot = isConfigFromFlag() ? '*' : '.';

  // Token display with origin indicator.
  const tokenPrefix = getVisibleTokenPrefix();
  const tokenOrigin = redacting ? '' : getTokenOrigin();
  const noApiToken = constants.default.ENV.SOCKET_CLI_NO_API_TOKEN;
  const shownToken = redacting ? REDACTED : noApiToken ? vendor.yoctocolorsCjsExports.red('(disabled)') : tokenPrefix ? `${vendor.yoctocolorsCjsExports.green(tokenPrefix)}***${tokenOrigin ? ` ${tokenOrigin}` : ''}` : vendor.yoctocolorsCjsExports.yellow('(not set)');
  const relCwd = redacting ? REDACTED : path$1.normalizePath(tildify(process.cwd()));

  // Consolidated org display format.
  const orgPart = redacting ? `org: ${REDACTED}` : orgFlag ? `org: ${vendor.yoctocolorsCjsExports.cyan(orgFlag)} (${constants.FLAG_ORG} flag)` : defaultOrg && defaultOrg !== 'null' ? `org: ${vendor.yoctocolorsCjsExports.cyan(defaultOrg)} (config)` : vendor.yoctocolorsCjsExports.yellow('org: (not set)');

  // Compact mode for CI/automation.
  if (compactMode) {
    const compactToken = noApiToken ? '(disabled)' : tokenPrefix ? `${tokenPrefix}***${tokenOrigin ? ` ${tokenOrigin}` : ''}` : '(not set)';
    const compactOrg = orgFlag || (defaultOrg && defaultOrg !== 'null' ? defaultOrg : '(not set)');
    return `CLI: ${cliVersion} | cmd: ${command} | org: ${compactOrg} | token: ${compactToken}`;
  }

  // Note: We could draw these with ascii box art instead but I worry about
  //       portability and paste-ability. "simple" ascii chars just work.
  const body = `
   _____         _       _        /---------------
  |   __|___ ___| |_ ___| |_      | CLI: ${cliVersion}
  |__   | ${configFromFlagDot} |  _| '_| -_|  _|     | ${showNodeVersion ? `Node: ${nodeVersion}, ` : ''}token: ${shownToken}, ${orgPart}
  |_____|___|___|_,_|___|_|.dev   | Command: \`${command}\`, cwd: ${relCwd}
  `.trim();
  // Note: logger will auto-append a newline.
  return `   ${body}`;
}

/**
 * Calculate Levenshtein distance between two strings for fuzzy matching.
 */
function levenshteinDistance(a, b) {
  const matrix = Array.from({
    length: a.length + 1
  }, () => Array(b.length + 1).fill(0));
  for (let i = 0; i <= a.length; i++) {
    matrix[i][0] = i;
  }
  for (let j = 0; j <= b.length; j++) {
    matrix[0][j] = j;
  }
  for (let i = 1; i <= a.length; i++) {
    for (let j = 1; j <= b.length; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      matrix[i][j] = Math.min(
      // Deletion.
      matrix[i - 1][j] + 1,
      // Insertion.
      matrix[i][j - 1] + 1,
      // Substitution.
      matrix[i - 1][j - 1] + cost);
    }
  }
  return matrix[a.length][b.length];
}

/**
 * Determine if the banner should be suppressed based on output flags.
 */
function shouldSuppressBanner(flags) {
  return Boolean(flags['json'] || flags['markdown'] || flags['banner'] === false);
}

/**
 * Emit the Socket CLI banner to stderr for branding and debugging.
 */
function emitBanner(name, orgFlag, compactMode = false) {
  // Print a banner at the top of each command.
  // This helps with brand recognition and marketing.
  // It also helps with debugging since it contains version and command details.
  // Note: print over stderr to preserve stdout for flags like --json and
  //       --markdown. If we don't do this, you can't use --json in particular
  //       and pipe the result to other tools. By emitting the banner over stderr
  //       you can do something like `socket scan view xyz | jq | process`.
  //       The spinner also emits over stderr for example.
  logger.logger.error(getAsciiHeader(name, orgFlag, compactMode));
}

/**
 * Main function for handling CLI with subcommands using meow.
 * @param config Configuration object with name, argv, importMeta, and subcommands.
 * @param options Optional settings like aliases and defaultSub.
 * @example
 * meowWithSubcommands(
 *   { name, argv, importMeta, subcommands },
 *   { aliases, defaultSub }
 * )
 */
async function meowWithSubcommands(config, options) {
  const {
    argv,
    importMeta,
    name,
    subcommands
  } = {
    __proto__: null,
    ...config
  };
  const {
    aliases = {},
    defaultSub,
    ...additionalOptions
  } = {
    __proto__: null,
    ...options
  };
  const flags$1 = {
    ...flags.commonFlags,
    version: {
      type: 'boolean',
      hidden: true,
      description: 'Print the app version'
    },
    ...require$$11.getOwn(additionalOptions, 'flags')
  };
  const [commandOrAliasName_, ...rawCommandArgv] = argv;
  let commandOrAliasName = commandOrAliasName_;
  if (!commandOrAliasName && defaultSub) {
    commandOrAliasName = defaultSub;
  }

  // No further args or first arg is a flag (shrug).
  const isRootCommand = name === 'socket' && (!commandOrAliasName || commandOrAliasName?.startsWith('-'));

  // Try to support `socket <purl>` as a shorthand for `socket package score <purl>`.
  if (!isRootCommand) {
    if (commandOrAliasName?.startsWith('pkg:')) {
      logger.logger.info('Invoking `socket package score`.');
      return await meowWithSubcommands({
        name,
        argv: ['package', 'deep', ...argv],
        importMeta,
        subcommands
      }, options);
    }
    // Support `socket npm/lodash` or whatever as a shorthand, too.
    // Accept any ecosystem and let the remote sort it out.
    if (/^[a-z]+\//.test(commandOrAliasName || '')) {
      logger.logger.info('Invoking `socket package score`.');
      return await meowWithSubcommands({
        name,
        argv: ['package', 'deep', `pkg:${commandOrAliasName}`, ...rawCommandArgv],
        importMeta,
        subcommands
      }, options);
    }
  }
  if (isRootCommand) {
    const hiddenDebugFlag = !require$$9.isDebug();
    flags$1['compactHeader'] = {
      ...flags$1['compactHeader'],
      hidden: false
    };
    flags$1['config'] = {
      ...flags$1['config'],
      hidden: false
    };
    flags$1['dryRun'] = {
      ...flags$1['dryRun'],
      hidden: false
    };
    flags$1['help'] = {
      ...flags$1['help'],
      hidden: false
    };
    flags$1['helpFull'] = {
      ...flags$1['helpFull'],
      hidden: false
    };
    flags$1['maxOldSpaceSize'] = {
      ...flags$1['maxOldSpaceSize'],
      hidden: hiddenDebugFlag
    };
    flags$1['maxSemiSpaceSize'] = {
      ...flags$1['maxSemiSpaceSize'],
      hidden: hiddenDebugFlag
    };
    flags$1['version'] = {
      ...flags$1['version'],
      hidden: false
    };
    delete flags$1['json'];
    delete flags$1['markdown'];
  } else {
    delete flags$1['help'];
    delete flags$1['helpFull'];
    delete flags$1['version'];
  }

  // This is basically a dry-run parse of cli args and flags. We use this to
  // determine config overrides and expected output mode.
  const cli1 = vendor.meow({
    argv,
    importMeta,
    ...additionalOptions,
    flags: flags$1,
    // Ensure we don't check unknown flags.
    allowUnknownFlags: true,
    // Prevent meow from potentially exiting early.
    autoHelp: false,
    autoVersion: false,
    // We want to detect whether a bool flag is given at all.
    booleanDefault: undefined
  });
  const {
    compactHeader: compactHeaderFlag,
    config: configFlag,
    org: orgFlag,
    spinner: spinnerFlag
  } = cli1.flags;
  const compactMode = compactHeaderFlag || constants.default.ENV.CI && !constants.default.ENV.VITEST;
  const noSpinner = spinnerFlag === false || require$$9.isDebug();

  // Use CI spinner style when --no-spinner is passed or debug mode is enabled.
  // This prevents the spinner from interfering with debug output.
  if (noSpinner) {
    constants.default.spinner.spinner = spinner.getCliSpinners('ci');
  }
  // Hard override the config if instructed to do so.
  // The env var overrides the --flag, which overrides the persisted config
  // Also, when either of these are used, config updates won't persist.
  let configOverrideResult;
  if (constants.default.ENV.SOCKET_CLI_CONFIG) {
    configOverrideResult = overrideCachedConfig(constants.default.ENV.SOCKET_CLI_CONFIG);
  } else if (configFlag) {
    configOverrideResult = overrideCachedConfig(configFlag);
  }
  if (constants.default.ENV.SOCKET_CLI_NO_API_TOKEN) {
    // This overrides the config override and even the explicit token env var.
    // The config will be marked as readOnly to prevent persisting it.
    overrideConfigApiToken(undefined);
  } else {
    const tokenOverride = constants.default.ENV.SOCKET_CLI_API_TOKEN;
    if (tokenOverride) {
      // This will set the token (even if there was a config override) and
      // set it to readOnly, making sure the temp token won't be persisted.
      overrideConfigApiToken(tokenOverride);
    }
  }
  if (configOverrideResult?.ok === false) {
    if (!shouldSuppressBanner(cli1.flags)) {
      emitBanner(name, orgFlag, compactMode);
      // Add newline in stderr.
      logger.logger.error('');
    }
    logger.logger.fail(configOverrideResult.message);
    process.exitCode = 2;
    return;
  }

  // If we have got some args, then lets find out if we can find a command.
  if (commandOrAliasName) {
    const alias = aliases[commandOrAliasName];
    // First: Resolve argv data from alias if its an alias that's been given.
    const [commandName, ...commandArgv] = alias ? [...alias.argv, ...rawCommandArgv] : [commandOrAliasName, ...rawCommandArgv];
    // Second: Find a command definition using that data.
    const commandDefinition = commandName ? subcommands[commandName] : undefined;
    // Third: If a valid command has been found, then we run it...
    if (commandDefinition) {
      // Extract the original command arguments from the full argv
      // by skipping the command name
      return await commandDefinition.run(commandArgv, importMeta, {
        parentName: name
      });
    }

    // Suggest similar commands for typos.
    if (commandName && !commandDefinition) {
      const suggestion = findBestCommandMatch(commandName, subcommands, aliases);
      if (suggestion) {
        process.exitCode = 2;
        logger.logger.fail(`Unknown command "${commandName}". Did you mean "${suggestion}"?`);
        return;
      }
    }
  }
  const lines = ['', 'Usage', `  $ ${name} <command>`];
  if (isRootCommand) {
    lines.push(`  $ ${name} scan create ${constants.FLAG_JSON}`, `  $ ${name} package score ${constants.NPM} lodash ${constants.FLAG_MARKDOWN}`);
  }
  lines.push('');
  if (isRootCommand) {
    // "Bucket" some commands for easier usage.
    const commands = new Set(['analytics', 'audit-log', 'ci', 'cdxgen', 'config', 'dependencies', 'fix', 'install',
    //'json',
    'license', 'login', 'logout', 'manifest', constants.NPM, constants.NPX, 'optimize', 'organization', 'package',
    //'patch',
    // PNPM,
    'raw-npm', 'raw-npx', 'repository', 'scan',
    //'security',
    'threat-feed', 'uninstall', 'wrapper'
    // YARN,
    ]);
    Object.entries(subcommands).filter(([_name, subcommand]) => !subcommand.hidden).map(([name]) => name).forEach(name => {
      if (commands.has(name)) {
        commands.delete(name);
      } else {
        logger.logger.fail('Received an unknown command:', name);
      }
    });
    if (commands.size) {
      logger.logger.fail('Found commands in the list that were not marked as public or not defined at all:',
      // Node < 22 will print 'Object (n)' before the array. So to have consistent
      // test snapshots we use joinAnd.
      arrays.joinAnd(Array.from(commands).sort(sorts.naturalCompare).map(c => `'${c}'`)));
    }
    lines.push('Note: All commands have their own --help', '', 'Main commands', `  socket login                ${description(subcommands['login'])}`, `  socket scan create          Create a new Socket scan and report`, `  socket npm/lodash@4.17.21   Request the Socket score of a package`, `  socket fix                  ${description(subcommands['fix'])}`, `  socket optimize             ${description(subcommands['optimize'])}`, `  socket cdxgen               ${description(subcommands['cdxgen'])}`, `  socket ci                   ${description(subcommands['ci'])}`, ``, 'Socket API', `  analytics                   ${description(subcommands['analytics'])}`, `  audit-log                   ${description(subcommands['audit-log'])}`, `  organization                ${description(subcommands['organization'])}`, `  package                     ${description(subcommands['package'])}`, `  repository                  ${description(subcommands['repository'])}`, `  scan                        ${description(subcommands['scan'])}`, `  threat-feed                 ${description(subcommands['threat-feed'])}`, ``, 'Local tools', `  manifest                    ${description(subcommands['manifest'])}`, `  npm                         ${description(subcommands[constants.NPM])}`, `  npx                         ${description(subcommands[constants.NPX])}`, `  raw-npm                     ${description(subcommands['raw-npm'])}`, `  raw-npx                     ${description(subcommands['raw-npx'])}`, '', 'CLI configuration', `  config                      ${description(subcommands['config'])}`, `  install                     ${description(subcommands['install'])}`, `  login                       Socket API login and CLI setup`, `  logout                      ${description(subcommands['logout'])}`, `  uninstall                   ${description(subcommands['uninstall'])}`, `  wrapper                     ${description(subcommands['wrapper'])}`);
  } else {
    lines.push('Commands');
    lines.push(`  ${getHelpListOutput({
      ...require$$11.toSortedObject(Object.fromEntries(Object.entries(subcommands).filter(({
        1: subcommand
      }) => !subcommand.hidden))),
      ...require$$11.toSortedObject(Object.fromEntries(Object.entries(aliases).filter(({
        1: alias
      }) => {
        const {
          hidden
        } = alias;
        const cmdName = hidden ? '' : alias.argv[0];
        const subcommand = cmdName ? subcommands[cmdName] : undefined;
        return subcommand && !subcommand.hidden;
      })))
    }, {
      indent: HELP_INDENT,
      padName: HELP_PAD_NAME
    })}`);
  }
  lines.push('', 'Options');
  if (isRootCommand) {
    lines.push('  Note: All commands have these flags even when not displayed in their help', '');
  } else {
    lines.push('');
  }
  lines.push(`  ${getFlagListOutput({
    ...flags$1,
    // Explicitly document the negated --no-banner variant.
    noBanner: {
      ...flags$1['banner'],
      hidden: false
    },
    // Explicitly document the negated --no-spinner variant.
    noSpinner: {
      ...flags$1['spinner'],
      hidden: false
    }
  }, {
    indent: HELP_INDENT,
    padName: HELP_PAD_NAME
  })}`);
  if (isRootCommand) {
    // Check if we should show full help with environment variables.
    const showFullHelp = argv.includes(constants.FLAG_HELP_FULL);
    if (showFullHelp) {
      // Show full help with environment variables.
      lines.push('', 'Environment variables', '  SOCKET_CLI_API_TOKEN        Set the Socket API token', '  SOCKET_CLI_CONFIG           A JSON stringified Socket configuration object', '  SOCKET_CLI_GITHUB_API_URL   Change the base URL for GitHub REST API calls', '  SOCKET_CLI_GIT_USER_EMAIL   The git config `user.email` used by Socket CLI', `                              ${vendor.yoctocolorsCjsExports.italic('Defaults:')} github-actions[bot]@users.noreply.github.com`, '  SOCKET_CLI_GIT_USER_NAME    The git config `user.name` used by Socket CLI', `                              ${vendor.yoctocolorsCjsExports.italic('Defaults:')} github-actions[bot]`, `  SOCKET_CLI_GITHUB_TOKEN     A classic or fine-grained ${vendor.terminalLinkExports('GitHub personal access token', 'https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens')}`, `                              ${vendor.yoctocolorsCjsExports.italic('Aliases:')} GITHUB_TOKEN`, '  SOCKET_CLI_NO_API_TOKEN     Make the default API token `undefined`', '  SOCKET_CLI_NPM_PATH         The absolute location of the npm directory', '  SOCKET_CLI_ORG_SLUG         Specify the Socket organization slug', '', '  SOCKET_CLI_ACCEPT_RISKS     Accept risks of a Socket wrapped npm/npx run', '  SOCKET_CLI_VIEW_ALL_RISKS   View all risks of a Socket wrapped npm/npx run', '', 'Environment variables for development', '  SOCKET_CLI_API_BASE_URL     Change the base URL for Socket API calls', `                              ${vendor.yoctocolorsCjsExports.italic('Defaults:')} The "apiBaseUrl" value of socket/settings local app data`, `                              if present, else ${constants.API_V0_URL}`, '  SOCKET_CLI_API_PROXY        Set the proxy Socket API requests are routed through, e.g. if set to', `                              ${vendor.terminalLinkExports('http://127.0.0.1:9090', 'https://docs.proxyman.io/troubleshooting/couldnt-see-any-requests-from-3rd-party-network-libraries')} then all request are passed through that proxy`, `                              ${vendor.yoctocolorsCjsExports.italic('Aliases:')} HTTPS_PROXY, https_proxy, HTTP_PROXY, and http_proxy`, '  SOCKET_CLI_API_TIMEOUT      Set the timeout in milliseconds for Socket API requests', '  SOCKET_CLI_DEBUG            Enable debug logging in Socket CLI', `  DEBUG                       Enable debug logging based on the ${socketPackageLink('npm', 'debug', undefined, 'debug')} package`);
    } else {
      // Show condensed help with hint about --help-full.
      lines.push('', 'Environment variables [more...]', `  Use ${vendor.yoctocolorsCjsExports.bold(constants.FLAG_HELP_FULL)} to view all environment variables`);
    }
  }

  // Parse it again. Config overrides should now be applied (may affect help).
  // Note: this is displayed as help screen if the command does not override it
  //       (which is the case for most sub-commands with sub-commands).
  const cli2 = vendor.meow({
    argv,
    importMeta,
    ...additionalOptions,
    flags: flags$1,
    // Do not strictly check for flags here.
    allowUnknownFlags: true,
    // We will emit help when we're ready.
    // Plus, if we allow this then meow may exit here.
    autoHelp: false,
    autoVersion: false,
    // We want to detect whether a bool flag is given at all.
    booleanDefault: undefined,
    help: lines.map(l => strings.indentString(l, HELP_INDENT)).join('\n')
  });
  const {
    dryRun,
    help: helpFlag
  } = cli2.flags;

  // ...else we provide basic instructions and help.
  if (!shouldSuppressBanner(cli2.flags)) {
    emitBanner(name, orgFlag, compactMode);
    // Meow will add newline so don't add stderr spacing here.
  }
  if (!helpFlag && dryRun) {
    process.exitCode = 0;
    logger.logger.log(`${constants.default.DRY_RUN_LABEL}: No-op, call a sub-command; ok`);
  } else {
    // When you explicitly request --help, the command should be successful
    // so we exit(0). If we do it because we need more input, we exit(2).
    cli2.showHelp(helpFlag ? 0 : 2);
  }
}
/**
 * Create meow CLI instance or exit with help/error (meow will exit immediately
 * if it calls .showHelp()).
 * @param config Configuration object with argv, config, parentName, and importMeta.
 * @param options Optional settings like allowUnknownFlags.
 * @example
 * meowOrExit(
 *   { argv, config, parentName, importMeta },
 *   { allowUnknownFlags: false }
 * )
 */
function meowOrExit(config, options) {
  const {
    argv,
    config: cliConfig,
    importMeta,
    parentName
  } = {
    __proto__: null,
    ...config
  };
  const {
    allowUnknownFlags = true
  } = {
    __proto__: null,
    ...options
  };
  const command = `${parentName} ${cliConfig.commandName}`;

  // This exits if .printHelp() is called either by meow itself or by us.
  const cli = vendor.meow({
    argv,
    // Prevent meow from potentially exiting early.
    autoHelp: false,
    autoVersion: false,
    // We want to detect whether a bool flag is given at all.
    booleanDefault: undefined,
    collectUnknownFlags: true,
    description: cliConfig.description,
    flags: cliConfig.flags,
    help: strings.trimNewlines(cliConfig.help(command, cliConfig)),
    importMeta
  });
  const {
    compactHeader: compactHeaderFlag,
    help: helpFlag,
    org: orgFlag,
    spinner: spinnerFlag,
    version: versionFlag
  } = cli.flags;
  const compactMode = compactHeaderFlag || constants.default.ENV.CI && !constants.default.ENV.VITEST;
  const noSpinner = spinnerFlag === false || require$$9.isDebug();

  // Use CI spinner style when --no-spinner is passed.
  // This prevents the spinner from interfering with debug output.
  if (noSpinner) {
    constants.default.spinner.spinner = spinner.getCliSpinners('ci');
  }
  if (!shouldSuppressBanner(cli.flags)) {
    emitBanner(command, orgFlag, compactMode);
    // Add newline in stderr.
    // Meow help adds a newline too so we do it here.
    logger.logger.error('');
  }

  // As per https://github.com/sindresorhus/meow/issues/178
  // Setting `allowUnknownFlags: false` makes it reject camel cased flags.
  // if (!allowUnknownFlags) {
  //   // Run meow specifically with the flag setting. It will exit(2) if an
  //   // invalid flag is set and print a message.
  //   meow({
  //     argv,
  //     allowUnknownFlags: false,
  //     // Prevent meow from potentially exiting early.
  //     autoHelp: false,
  //     autoVersion: false,
  //     description: config.description,
  //     flags: config.flags,
  //     help: trimNewlines(config.help(command, config)),
  //     importMeta,
  //   })
  // }

  if (helpFlag) {
    cli.showHelp(0);
  }

  // Meow doesn't detect 'version' as an unknown flag, so we do the leg work here.
  if (versionFlag && !require$$11.hasOwn(cliConfig.flags, 'version')) {
    // Use `console.error` here instead of `logger.error` to match Meow behavior.
    console.error('Unknown flag\n--version');
    // eslint-disable-next-line n/no-process-exit
    process.exit(2);
    // This line is never reached in production, but helps tests.
    throw new Error('process.exit called');
  }

  // Now test for help state. Run Meow again. If it exits now, it must be due
  // to wanting to print the help screen. But it would exit(0) and we want a
  // consistent exit(2) for that case (missing input).
  process.exitCode = 2;
  vendor.meow({
    argv,
    // As per https://github.com/sindresorhus/meow/issues/178
    // Setting `allowUnknownFlags: false` makes it reject camel cased flags.
    allowUnknownFlags: Boolean(allowUnknownFlags),
    // Prevent meow from potentially exiting early.
    autoHelp: false,
    autoVersion: false,
    description: cliConfig.description,
    help: strings.trimNewlines(cliConfig.help(command, cliConfig)),
    importMeta,
    flags: cliConfig.flags
  });
  // Ok, no help, reset to default.
  process.exitCode = 0;
  return cli;
}

function msAtHome(isoTimeStamp) {
  const timeStart = Date.parse(isoTimeStamp);
  const timeEnd = Date.now();
  const rtf = new Intl.RelativeTimeFormat('en', {
    numeric: 'always',
    style: 'short'
  });
  const delta = timeEnd - timeStart;
  if (delta < 60 * 60 * 1000) {
    return rtf.format(-Math.round(delta / (60 * 1000)), 'minute');
    // return Math.round(delta / (60 * 1000)) + ' min ago'
  } else if (delta < 24 * 60 * 60 * 1000) {
    return rtf.format(-(delta / (60 * 60 * 1000)).toFixed(1), 'hour');
    // return (delta / (60 * 60 * 1000)).toFixed(1) + ' hr ago'
  } else if (delta < 7 * 24 * 60 * 60 * 1000) {
    return rtf.format(-(delta / (24 * 60 * 60 * 1000)).toFixed(1), 'day');
    // return (delta / (24 * 60 * 60 * 1000)).toFixed(1) + ' day ago'
  } else {
    return isoTimeStamp.slice(0, 10);
  }
}

async function fetchOrganization(options) {
  const {
    description = 'organization list',
    sdk,
    sdkOpts
  } = {
    __proto__: null,
    ...options
  };
  let sockSdk = sdk;
  if (!sockSdk) {
    const sockSdkCResult = await setupSdk(sdkOpts);
    if (!sockSdkCResult.ok) {
      return sockSdkCResult;
    }
    sockSdk = sockSdkCResult.data;
  }
  const orgsCResult = await handleApiCall(sockSdk.getOrganizations(), {
    description
  });
  if (!orgsCResult.ok) {
    return orgsCResult;
  }
  return {
    ...orgsCResult,
    data: {
      organizations: Object.values(orgsCResult.data.organizations)
    }
  };
}

async function suggestOrgSlug() {
  const orgsCResult = await fetchOrganization();
  if (!orgsCResult.ok) {
    logger.logger.fail('Failed to lookup organization list from API, unable to suggest');
    return undefined;
  }

  // Ignore a failed request here. It was not the primary goal of
  // running this command and reporting it only leads to end-user confusion.
  const {
    organizations
  } = orgsCResult.data;
  const proceed = await prompts.select({
    message: 'Missing org name; do you want to use any of these orgs for this scan?',
    choices: [...organizations.map(o => {
      const name = o.name ?? o.slug;
      return {
        name: `Yes [${name}]`,
        value: name,
        description: `Use "${name}" as the organization`
      };
    }), {
      name: 'No',
      value: '',
      description: 'Do not use any of these organizations (will end in a no-op)'
    }]
  });
  if (proceed) {
    return proceed;
  }
  return undefined;
}

async function suggestToPersistOrgSlug(orgSlug) {
  const skipAsk = getConfigValue('skipAskToPersistDefaultOrg');
  if (!skipAsk.ok || skipAsk.data) {
    // Don't ask to store it when disabled before, or when reading config fails.
    return;
  }
  const result = await prompts.select({
    message: `Would you like to use this org (${orgSlug}) as the default org for future calls?`,
    choices: [{
      name: 'Yes',
      value: 'yes',
      description: 'Stores it in your config'
    }, {
      name: 'No',
      value: 'no',
      description: 'Do not persist this org as default org'
    }, {
      name: "No and don't ask again",
      value: 'sush',
      description: 'Do not store as default org and do not ask again to persist it'
    }]
  });
  if (result === 'yes') {
    const updateResult = updateConfigValue('defaultOrg', orgSlug);
    if (updateResult.ok) {
      logger.logger.success('Updated default org config to:', orgSlug);
    } else {
      logger.logger.fail('(Non blocking) Failed to update default org in config:', updateResult.cause);
    }
  } else if (result === 'sush') {
    const updateResult = updateConfigValue('skipAskToPersistDefaultOrg', true);
    if (updateResult.ok) {
      logger.logger.info('Default org not changed. Will not ask to persist again.');
    } else {
      logger.logger.fail(`(Non blocking) Failed to store preference; will ask to persist again next time. Reason: ${updateResult.cause}`);
    }
  }
}

async function determineOrgSlug(orgFlag, interactive, dryRun) {
  const defaultOrgSlug = getConfigValueOrUndef(constants.CONFIG_KEY_DEFAULT_ORG);
  let orgSlug = String(orgFlag || defaultOrgSlug || '');
  if (!orgSlug) {
    if (!interactive) {
      logger.logger.warn('Note: This command requires an org slug because the Socket API endpoint does.');
      logger.logger.warn('');
      logger.logger.warn('It seems no default org was setup and the `--org` flag was not used.');
      logger.logger.warn("Additionally, `--no-interactive` was set so we can't ask for it.");
      logger.logger.warn('Since v1.0.0 the org _argument_ for all commands was dropped in favor of an');
      logger.logger.warn('implicit default org setting, which will be setup when you run `socket login`.');
      logger.logger.warn('');
      logger.logger.warn('Note: When running in CI, you probably want to set the `--org` flag.');
      logger.logger.warn('');
      logger.logger.warn(`For details, see the ${webLink(constants.V1_MIGRATION_GUIDE_URL, 'v1 migration guide')}`);
      logger.logger.warn('');
      logger.logger.warn('This command will exit now because the org slug is required to proceed.');
      return ['', undefined];
    }
    logger.logger.warn('Unable to determine the target org. Trying to auto-discover it now...');
    logger.logger.info('Note: Run `socket login` to set a default org.');
    logger.logger.error('      Use the --org flag to override the default org.');
    logger.logger.error('');
    if (dryRun) {
      logger.logger.fail('Skipping auto-discovery of org in dry-run mode');
    } else {
      orgSlug = (await suggestOrgSlug()) || '';
      if (orgSlug) {
        await suggestToPersistOrgSlug(orgSlug);
      }
    }
  }
  return [orgSlug, defaultOrgSlug];
}

// Use the config defaultOrg when set, otherwise discover from remote.
async function getDefaultOrgSlug() {
  const defaultOrgResult = getConfigValueOrUndef('defaultOrg');
  if (defaultOrgResult) {
    require$$9.debugFn('notice', 'use: org from "defaultOrg" value of socket/settings local app data', defaultOrgResult);
    return {
      ok: true,
      data: defaultOrgResult
    };
  }
  const envOrgSlug = constants.default.ENV.SOCKET_CLI_ORG_SLUG;
  if (envOrgSlug) {
    require$$9.debugFn('notice', 'use: org from SOCKET_CLI_ORG_SLUG environment variable', envOrgSlug);
    return {
      ok: true,
      data: envOrgSlug
    };
  }
  const orgsCResult = await fetchOrganization();
  if (!orgsCResult.ok) {
    return orgsCResult;
  }
  const {
    organizations
  } = orgsCResult.data;
  const keys = Object.keys(organizations);
  if (!keys.length) {
    return {
      ok: false,
      message: 'Failed to establish identity',
      data: `No organization associated with the Socket API token. Unable to continue.`
    };
  }
  const slug = organizations[keys[0]]?.name ?? undefined;
  if (!slug) {
    return {
      ok: false,
      message: 'Failed to establish identity',
      data: `Cannot determine the default organization for the API token. Unable to continue.`
    };
  }
  require$$9.debugFn('notice', 'resolve: org from Socket API', slug);
  return {
    ok: true,
    message: 'Retrieved default org from server',
    data: slug
  };
}

/**
 * Sanitizes a name to comply with repository naming constraints.
 * Constraints: 100 or less A-Za-z0-9 characters only with non-repeating,
 * non-leading or trailing ., _ or - only.
 *
 * @param name - The name to sanitize
 * @returns Sanitized name that complies with repository naming rules, or empty string if no valid characters
 */
function sanitizeName(name) {
  if (!name) {
    return '';
  }

  // Replace sequences of illegal characters with underscores.
  const sanitized = name
  // Replace any sequence of non-alphanumeric characters (except ., _, -) with underscore.
  .replace(/[^A-Za-z0-9._-]+/g, '_')
  // Replace sequences of multiple allowed special chars with single underscore.
  .replace(/[._-]{2,}/g, '_')
  // Remove leading special characters.
  .replace(/^[._-]+/, '')
  // Remove trailing special characters.
  .replace(/[._-]+$/, '')
  // Truncate to 100 characters max.
  .slice(0, 100);
  return sanitized;
}

/**
 * Extracts and sanitizes a repository name.
 *
 * @param name - The repository name to extract and sanitize
 * @returns Sanitized repository name, or default repository name if empty
 */
function extractName(name) {
  const sanitized = sanitizeName(name);
  return sanitized || constants.default.SOCKET_DEFAULT_REPOSITORY;
}

/**
 * Git utilities for Socket CLI.
 * Provides git operations for repository management, branch handling, and commits.
 *
 * Branch Operations:
 * - gitCheckoutBranch: Switch to branch
 * - gitCreateBranch: Create new local branch
 * - gitDeleteBranch: Delete local branch
 * - gitDeleteRemoteBranch: Delete remote branch
 * - gitPushBranch: Push branch to remote with --force
 *
 * Commit Operations:
 * - gitCleanFdx: Remove untracked files
 * - gitCommit: Stage files and create commit
 * - gitEnsureIdentity: Configure git user.name/email
 * - gitResetHard: Reset to branch/commit
 *
 * Remote URL Parsing:
 * - parseGitRemoteUrl: Extract owner/repo from SSH or HTTPS URLs
 *
 * Repository Information:
 * - detectDefaultBranch: Find default branch (main/master/develop/etc)
 * - getBaseBranch: Determine base branch (respects GitHub Actions env)
 * - getRepoInfo: Extract owner/repo from git remote URL
 * - gitBranch: Get current branch or commit hash
 */

// Listed in order of check preference.
const COMMON_DEFAULT_BRANCH_NAMES = [
// Modern default (GitHub, GitLab, Bitbucket have switched to this).
'main',
// Historic default in Git (pre-2020, still used in many repos).
'master',
// Common in Git Flow workflows (main for stable, develop for ongoing work).
'develop',
// Used by teams adopting trunk-based development practices.
'trunk',
// Used in some older enterprise setups and tools.
'default'];
async function getBaseBranch(cwd = process.cwd()) {
  const {
    GITHUB_BASE_REF,
    GITHUB_REF_NAME,
    GITHUB_REF_TYPE
  } = constants.default.ENV;
  // 1. In a pull request, this is always the base branch.
  if (GITHUB_BASE_REF) {
    return GITHUB_BASE_REF;
  }
  // 2. If it's a branch (not a tag), GITHUB_REF_TYPE should be 'branch'.
  if (GITHUB_REF_TYPE === 'branch' && GITHUB_REF_NAME) {
    return GITHUB_REF_NAME;
  }
  // 3. Try to resolve the default remote branch using 'git remote show origin'.
  // This handles detached HEADs or workflows triggered by tags/releases.
  try {
    const originDetails = (await spawn.spawn('git', ['remote', 'show', 'origin'], {
      cwd
    })).stdout;
    const match = /(?<=HEAD branch: ).+/.exec(originDetails);
    if (match?.[0]) {
      return match[0].trim();
    }
  } catch {}
  // GitHub and GitLab default to branch name "main"
  // https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-branches#about-the-default-branch
  return 'main';
}
async function getRepoInfo(cwd = process.cwd()) {
  let info;
  try {
    const remoteUrl = (await spawn.spawn('git', ['remote', 'get-url', 'origin'], {
      cwd
    })).stdout;
    info = parseGitRemoteUrl(remoteUrl);
    if (!info) {
      require$$9.debugFn('warn', `Unmatched git remote URL format: ${remoteUrl}`);
      require$$9.debugDir('warn', {
        remoteUrl
      });
    }
  } catch (e) {
    // Expected failure when not in a git repo.
    require$$9.debugDir('inspect', {
      message: 'git remote get-url failed',
      error: e
    });
  }
  return info;
}
async function getRepoName(cwd = process.cwd()) {
  const repoInfo = await getRepoInfo(cwd);
  return repoInfo?.repo ? extractName(repoInfo.repo) : constants.default.SOCKET_DEFAULT_REPOSITORY;
}
async function gitBranch(cwd = process.cwd()) {
  const stdioPipeOptions = {
    cwd
  };
  // Try symbolic-ref first which returns the branch name or fails in a
  // detached HEAD state.
  try {
    const gitSymbolicRefResult = await spawn.spawn('git', ['symbolic-ref', '--short', 'HEAD'], stdioPipeOptions);
    return gitSymbolicRefResult.stdout;
  } catch (e) {
    // Expected in detached HEAD state, fallback to rev-parse.
    require$$9.debugDir('inspect', {
      message: 'In detached HEAD state',
      error: e
    });
  }
  // Fallback to using rev-parse to get the short commit hash in a
  // detached HEAD state.
  try {
    const gitRevParseResult = await spawn.spawn('git', ['rev-parse', '--short', 'HEAD'], stdioPipeOptions);
    return gitRevParseResult.stdout;
  } catch (e) {
    // Both methods failed, likely not in a git repo.
    require$$9.debugDir('inspect', {
      message: 'Unable to determine git branch',
      error: e
    });
  }
  return undefined;
}

/**
 * Try to detect the default branch name by checking common patterns.
 * Returns the first branch that exists in the repository.
 */
async function detectDefaultBranch(cwd = process.cwd()) {
  // First pass: check all local branches
  for (const branch of COMMON_DEFAULT_BRANCH_NAMES) {
    // eslint-disable-next-line no-await-in-loop
    if (await gitLocalBranchExists(branch, cwd)) {
      return branch;
    }
  }
  // Second pass: check remote branches only if no local branch found
  for (const branch of COMMON_DEFAULT_BRANCH_NAMES) {
    // eslint-disable-next-line no-await-in-loop
    if (await gitRemoteBranchExists(branch, cwd)) {
      return branch;
    }
  }
  return constants.default.SOCKET_DEFAULT_BRANCH;
}
async function gitCleanFdx(cwd = process.cwd()) {
  const stdioIgnoreOptions = {
    cwd,
    stdio: require$$9.isDebug('stdio') ? 'inherit' : 'ignore'
  };
  try {
    await spawn.spawn('git', ['clean', '-fdx'], stdioIgnoreOptions);
    debugGit('clean -fdx', true);
    return true;
  } catch (e) {
    debugGit('clean -fdx', false, {
      error: e
    });
  }
  return false;
}
async function gitCheckoutBranch(branch, cwd = process.cwd()) {
  const stdioIgnoreOptions = {
    cwd,
    stdio: require$$9.isDebug('stdio') ? 'inherit' : 'ignore'
  };
  try {
    await spawn.spawn('git', ['checkout', branch], stdioIgnoreOptions);
    debugGit(`checkout ${branch}`, true);
    return true;
  } catch (e) {
    debugGit(`checkout ${branch}`, false, {
      error: e
    });
  }
  return false;
}
async function gitCreateBranch(branch, cwd = process.cwd()) {
  if (await gitLocalBranchExists(branch)) {
    return true;
  }
  const stdioIgnoreOptions = {
    cwd,
    stdio: require$$9.isDebug('stdio') ? 'inherit' : 'ignore'
  };
  try {
    await spawn.spawn('git', ['branch', branch], stdioIgnoreOptions);
    debugGit(`branch ${branch}`, true);
    return true;
  } catch (e) {
    debugGit(`branch ${branch}`, false, {
      error: e
    });
  }
  return false;
}
async function gitPushBranch(branch, cwd = process.cwd()) {
  const stdioIgnoreOptions = {
    cwd,
    stdio: require$$9.isDebug('stdio') ? 'inherit' : 'ignore'
  };
  try {
    await spawn.spawn('git', ['push', '--force', '--set-upstream', 'origin', branch], stdioIgnoreOptions);
    debugGit(`push ${branch}`, true);
    return true;
  } catch (e) {
    if (spawn.isSpawnError(e) && e.code === 128) {
      require$$9.debugFn('error', "Push denied: token requires write permissions for 'contents' and 'pull-requests'");
      require$$9.debugDir('error', e);
      require$$9.debugDir('inspect', {
        branch
      });
    } else {
      debugGit(`push ${branch}`, false, {
        error: e
      });
    }
  }
  return false;
}
async function gitCommit(commitMsg, filepaths, options) {
  if (!filepaths.length) {
    require$$9.debugFn('notice', `miss: no filepaths to add`);
    return false;
  }
  const {
    cwd = process.cwd(),
    email = constants.default.ENV.SOCKET_CLI_GIT_USER_EMAIL,
    user = constants.default.ENV.SOCKET_CLI_GIT_USER_NAME
  } = {
    __proto__: null,
    ...options
  };
  await gitEnsureIdentity(user, email, cwd);
  const stdioIgnoreOptions = {
    cwd,
    stdio: require$$9.isDebug('stdio') ? 'inherit' : 'ignore'
  };
  try {
    await spawn.spawn('git', ['add', ...filepaths], stdioIgnoreOptions);
    debugGit('add', true, {
      count: filepaths.length
    });
  } catch (e) {
    debugGit('add', false, {
      error: e
    });
    require$$9.debugDir('inspect', {
      filepaths
    });
    return false;
  }
  try {
    await spawn.spawn('git', ['commit', '-m', commitMsg], stdioIgnoreOptions);
    debugGit('commit', true);
    return true;
  } catch (e) {
    debugGit('commit', false, {
      error: e
    });
    require$$9.debugDir('inspect', {
      commitMsg
    });
  }
  return false;
}
async function gitDeleteBranch(branch, cwd = process.cwd()) {
  const stdioIgnoreOptions = {
    cwd,
    stdio: require$$9.isDebug('stdio') ? 'inherit' : 'ignore'
  };
  try {
    // Will throw with exit code 1 if branch does not exist.
    await spawn.spawn('git', ['branch', '-D', branch], stdioIgnoreOptions);
    return true;
  } catch (e) {
    // Expected failure when branch doesn't exist.
    require$$9.debugDir('inspect', {
      message: `Branch deletion failed (may not exist): ${branch}`,
      error: e
    });
  }
  return false;
}
async function gitEnsureIdentity(name, email, cwd = process.cwd()) {
  const stdioPipeOptions = {
    cwd
  };
  const identEntries = [['user.email', email], ['user.name', name]];
  await Promise.all(identEntries.map(async ({
    0: prop,
    1: value
  }) => {
    let configValue;
    try {
      // Will throw with exit code 1 if the config property is not set.
      const gitConfigResult = await spawn.spawn('git', ['config', '--get', prop], stdioPipeOptions);
      configValue = gitConfigResult.stdout;
    } catch (e) {
      // Expected when config property is not set.
      require$$9.debugDir('inspect', {
        message: `Git config property not set: ${prop}`,
        error: e
      });
    }
    if (configValue !== value) {
      const stdioIgnoreOptions = {
        cwd,
        stdio: require$$9.isDebug('stdio') ? 'inherit' : 'ignore'
      };
      try {
        await spawn.spawn('git', ['config', prop, value], stdioIgnoreOptions);
      } catch (e) {
        require$$9.debugFn('warn', `Failed to set git config: ${prop}`);
        require$$9.debugDir('warn', e);
        require$$9.debugDir('inspect', {
          value
        });
      }
    }
  }));
}
async function gitLocalBranchExists(branch, cwd = process.cwd()) {
  const stdioIgnoreOptions = {
    cwd,
    stdio: require$$9.isDebug('stdio') ? 'inherit' : 'ignore'
  };
  try {
    // Will throw with exit code 1 if the branch does not exist.
    await spawn.spawn('git', ['show-ref', constants.FLAG_QUIET, `refs/heads/${branch}`], stdioIgnoreOptions);
    return true;
  } catch {
    // Expected when branch doesn't exist - no logging needed.
  }
  return false;
}
async function gitRemoteBranchExists(branch, cwd = process.cwd()) {
  const stdioPipeOptions = {
    cwd
  };
  try {
    const lsRemoteResult = await spawn.spawn('git', ['ls-remote', '--heads', 'origin', branch], stdioPipeOptions);
    return lsRemoteResult.stdout.length > 0;
  } catch (e) {
    // Expected when remote is not accessible or branch doesn't exist.
    require$$9.debugDir('inspect', {
      message: `Remote branch check failed: ${branch}`,
      error: e
    });
  }
  return false;
}
async function gitResetAndClean(branch = 'HEAD', cwd = process.cwd()) {
  // Discards tracked changes.
  await gitResetHard(branch, cwd);
  // Deletes all untracked files and directories.
  await gitCleanFdx(cwd);
}
async function gitResetHard(branch = 'HEAD', cwd = process.cwd()) {
  const stdioIgnoreOptions = {
    cwd,
    stdio: require$$9.isDebug('stdio') ? 'inherit' : 'ignore'
  };
  try {
    await spawn.spawn('git', ['reset', '--hard', branch], stdioIgnoreOptions);
    debugGit(`reset --hard ${branch}`, true);
    return true;
  } catch (e) {
    debugGit(`reset --hard ${branch}`, false, {
      error: e
    });
  }
  return false;
}
async function gitUnstagedModifiedFiles(cwd = process.cwd()) {
  const stdioPipeOptions = {
    cwd
  };
  try {
    const gitDiffResult = await spawn.spawn('git', ['diff', '--name-only'], stdioPipeOptions);
    const changedFilesDetails = gitDiffResult.stdout;
    const relPaths = changedFilesDetails.split('\n');
    return {
      ok: true,
      data: relPaths.map(p => path$1.normalizePath(p))
    };
  } catch (e) {
    require$$9.debugFn('error', 'Failed to get unstaged modified files');
    require$$9.debugDir('error', e);
    return {
      ok: false,
      message: 'Git Error',
      cause: 'Unexpected error while trying to ask git whether repo is dirty'
    };
  }
}
const parsedGitRemoteUrlCache = new Map();
function parseGitRemoteUrl(remoteUrl) {
  let result = parsedGitRemoteUrlCache.get(remoteUrl);
  if (result) {
    return {
      ...result
    };
  }
  // Handle SSH-style
  const sshMatch = /^git@[^:]+:([^/]+)\/(.+?)(?:\.git)?$/.exec(remoteUrl);
  // 1. Handle SSH-style, e.g. git@github.com:owner/repo.git
  if (sshMatch) {
    result = {
      owner: sshMatch[1],
      repo: sshMatch[2]
    };
  } else {
    // 2. Handle HTTPS/URL-style, e.g. https://github.com/owner/repo.git
    try {
      const parsed = new URL(remoteUrl);
      // Remove leading slashes from pathname and split by "/" to extract segments.
      const segments = parsed.pathname.replace(/^\/+/, '').split('/');
      // The second-to-last segment is expected to be the owner (e.g., "owner" in /owner/repo.git).
      const owner = segments.at(-2);
      // The last segment is expected to be the repo name, so we remove the ".git" suffix if present.
      const repo = segments.at(-1)?.replace(/\.git$/, '');
      if (owner && repo) {
        result = {
          owner,
          repo
        };
      }
    } catch {}
  }
  parsedGitRemoteUrlCache.set(remoteUrl, result);
  return result ? {
    ...result
  } : result;
}

/**
 * Package URL (PURL) utilities for Socket CLI.
 * Implements the PURL specification for universal package identification.
 *
 * PURL Format:
 * pkg:type/namespace/name@version?qualifiers#subpath
 *
 * Key Functions:
 * - createPurlObject: Create PURL from components
 * - isPurl: Check if string is valid PURL
 * - normalizePurl: Normalize PURL format
 * - parsePurl: Parse PURL string to object
 * - purlToString: Convert PURL object to string
 *
 * Supported Types:
 * - cargo: Rust packages
 * - gem: Ruby packages
 * - go: Go modules
 * - maven: Java packages
 * - npm: Node.js packages
 * - pypi: Python packages
 *
 * See: https://github.com/package-url/purl-spec
 */

function createPurlObject(type, name, options) {
  let opts;
  if (require$$11.isObjectObject(type)) {
    opts = {
      __proto__: null,
      ...type
    };
    type = opts.type;
    name = opts.name;
  } else if (require$$11.isObjectObject(name)) {
    opts = {
      __proto__: null,
      ...name
    };
    name = opts.name;
  } else {
    opts = {
      __proto__: null,
      ...options
    };
    if (typeof name !== 'string') {
      name = opts.name;
    }
  }
  const {
    namespace,
    qualifiers,
    subpath,
    throws,
    version
  } = opts;
  const shouldThrow = throws === undefined || !!throws;
  try {
    return new vendor.packageurlJsExports.PackageURL(type, namespace, name, version, qualifiers, subpath);
  } catch (e) {
    if (shouldThrow) {
      throw e;
    }
  }
  return undefined;
}
function getPurlObject(purl, options) {
  const {
    throws
  } = {
    __proto__: null,
    ...options
  };
  const shouldThrow = throws === undefined || !!throws;
  try {
    return typeof purl === 'string' ? vendor.packageurlJsExports.PackageURL.fromString(normalizePurl(purl)) : purl;
  } catch (e) {
    if (shouldThrow) {
      throw e;
    }
    return undefined;
  }
}
function normalizePurl(rawPurl) {
  return rawPurl.startsWith('pkg:') ? rawPurl : `pkg:${rawPurl}`;
}

/**
 * Socket.dev URL utilities for Socket CLI.
 * Generates URLs for Socket.dev website features and resources.
 *
 * Key Functions:
 * - getPkgFullNameFromPurl: Extract full package name from PURL
 * - getSocketDevAlertUrl: Generate alert type documentation URL
 * - getSocketDevPackageOverviewUrl: Generate package overview URL
 * - getSocketDevPackageOverviewUrlFromPurl: Generate overview URL from PURL
 * - getSocketDevPackageUrl: Generate package detail URL
 * - getSocketDevPackageUrlFromPurl: Generate package URL from PURL
 * - getSocketDevReportUrl: Generate scan report URL
 *
 * URL Generation:
 * - Package overview and detail pages
 * - Security alert documentation
 * - Scan report links
 * - Ecosystem-specific URL formatting
 */

function getPkgFullNameFromPurl(purl) {
  const purlObj = getPurlObject(purl);
  const {
    name,
    namespace
  } = purlObj;
  return namespace ? `${namespace}${purlObj.type === 'maven' ? ':' : '/'}${name}` : name;
}
function getSocketDevPackageOverviewUrlFromPurl(purl) {
  const purlObj = getPurlObject(purl);
  const fullName = getPkgFullNameFromPurl(purlObj);
  return getSocketDevPackageOverviewUrl(purlObj.type, fullName, purlObj.version);
}
function getSocketDevPackageOverviewUrl(ecosystem, fullName, version) {
  const url = `${constants.default.SOCKET_WEBSITE_URL}/${ecosystem}/package/${fullName}`;
  return ecosystem === 'golang' ? `${url}${version ? `?section=overview&version=${version}` : ''}` : `${url}${version ? `/overview/${version}` : ''}`;
}

/**
 * Convert a Map<string, Map|string> to a nested object of similar shape.
 * The goal is to serialize it with JSON.stringify, which Map can't do.
 */
function mapToObject(map) {
  return Object.fromEntries(Array.from(map.entries()).map(([k, v]) => [k, v instanceof Map ? mapToObject(v) : v]));
}

function* walkNestedMap(map, keys = []) {
  for (const {
    0: key,
    1: value
  } of map.entries()) {
    if (value instanceof Map) {
      yield* walkNestedMap(value, [...keys, key]);
    } else {
      yield {
        keys: [...keys, key],
        value: value
      };
    }
  }
}

/**
 * Coana integration utilities for Socket CLI.
 * Manages reachability analysis via Coana tech CLI.
 *
 * Key Functions:
 * - extractTier1ReachabilityScanId: Extract scan ID from socket facts file
 *
 * Integration:
 * - Works with @coana-tech/cli for reachability analysis
 * - Processes socket facts JSON files
 * - Extracts tier 1 reachability scan identifiers
 */

function extractTier1ReachabilityScanId(socketFactsFile) {
  const json = fs.readJsonSync(socketFactsFile, {
    throws: false
  });
  const tier1ReachabilityScanId = String(json?.['tier1ReachabilityScanId'] ?? '').trim();
  return tier1ReachabilityScanId.length > 0 ? tier1ReachabilityScanId : undefined;
}

/**
 * File system utilities for Socket CLI.
 * Provides file and directory search functionality.
 *
 * Key Functions:
 * - findUp: Search for files/directories up the directory tree
 *
 * Features:
 * - Upward directory traversal
 * - Supports file and directory searching
 * - Abort signal support for cancellation
 * - Multiple name search support
 *
 * Usage:
 * - Finding configuration files (package.json, lockfiles)
 * - Locating project root directories
 * - Searching for specific files in parent directories
 */

async function findUp(name, options) {
  const opts = {
    __proto__: null,
    ...options
  };
  const {
    cwd = process.cwd(),
    signal = constants.default.abortSignal
  } = opts;
  let {
    onlyDirectories = false,
    onlyFiles = true
  } = opts;
  if (onlyDirectories) {
    onlyFiles = false;
  }
  if (onlyFiles) {
    onlyDirectories = false;
  }
  let dir = path.resolve(cwd);
  const {
    root
  } = path.parse(dir);
  const names = [name].flat();
  while (dir && dir !== root) {
    for (const name of names) {
      if (signal?.aborted) {
        return undefined;
      }
      const thePath = path.join(dir, name);
      try {
        // eslint-disable-next-line no-await-in-loop
        const stats = await fs$1.promises.stat(thePath);
        if (!onlyDirectories && stats.isFile()) {
          return thePath;
        }
        if (!onlyFiles && stats.isDirectory()) {
          return thePath;
        }
      } catch {}
    }
    dir = path.dirname(dir);
  }
  return undefined;
}

const DEFAULT_IGNORE_FOR_GIT_IGNORE = globs.defaultIgnore.filter(p => !p.endsWith('.gitignore'));
const IGNORED_DIRS = [
// Taken from ignore-by-default:
// https://github.com/novemberborn/ignore-by-default/blob/v2.1.0/index.js
'.git',
// Git repository files, see <https://git-scm.com/>
'.log',
// Log files emitted by tools such as `tsserver`, see <https://github.com/Microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29>
'.nyc_output',
// Temporary directory where nyc stores coverage data, see <https://github.com/bcoe/nyc>
'.sass-cache',
// Cache folder for node-sass, see <https://github.com/sass/node-sass>
'.yarn',
// Where node modules are installed when using Yarn, see <https://yarnpkg.com/>
'bower_components',
// Where Bower packages are installed, see <http://bower.io/>
'coverage',
// Standard output directory for code coverage reports, see <https://github.com/gotwarlost/istanbul>
constants.NODE_MODULES,
// Where Node modules are installed, see <https://nodejs.org/>
// Taken from globby:
// https://github.com/sindresorhus/globby/blob/v14.0.2/ignore.js#L11-L16
'flow-typed'];
const IGNORED_DIR_PATTERNS = IGNORED_DIRS.map(i => `**/${i}`);
async function getWorkspaceGlobs(agent, cwd = process.cwd()) {
  let workspacePatterns;
  if (agent === constants.PNPM) {
    const workspacePath = path.join(cwd, 'pnpm-workspace.yaml');
    const yml = await fs.safeReadFile(workspacePath);
    if (yml) {
      try {
        workspacePatterns = vendor.distExports$1.parse(yml)?.packages;
      } catch {}
    }
  } else {
    workspacePatterns = (await packages.readPackageJson(cwd, {
      throws: false
    }))?.['workspaces'];
  }
  return Array.isArray(workspacePatterns) ? workspacePatterns.filter(strings.isNonEmptyString).map(workspacePatternToGlobPattern) : [];
}
function ignoreFileLinesToGlobPatterns(lines, filepath, cwd) {
  const base = path.relative(cwd, path.dirname(filepath)).replace(/\\/g, '/');
  const patterns = [];
  for (let i = 0, {
      length
    } = lines; i < length; i += 1) {
    const pattern = lines[i].trim();
    if (pattern.length > 0 && pattern.charCodeAt(0) !== 35 /*'#'*/) {
      patterns.push(ignorePatternToMinimatch(pattern.length && pattern.charCodeAt(0) === 33 /*'!'*/ ? `!${path.posix.join(base, pattern.slice(1))}` : path.posix.join(base, pattern)));
    }
  }
  return patterns;
}
function ignoreFileToGlobPatterns(content, filepath, cwd) {
  return ignoreFileLinesToGlobPatterns(content.split(/\r?\n/), filepath, cwd);
}

// Based on `@eslint/compat` convertIgnorePatternToMinimatch.
// Apache v2.0 licensed
// Copyright Nicholas C. Zakas
// https://github.com/eslint/rewrite/blob/compat-v1.2.1/packages/compat/src/ignore-file.js#L28
function ignorePatternToMinimatch(pattern) {
  const isNegated = pattern.startsWith('!');
  const negatedPrefix = isNegated ? '!' : '';
  const patternToTest = (isNegated ? pattern.slice(1) : pattern).trimEnd();
  // Special cases.
  if (patternToTest === '' || patternToTest === '**' || patternToTest === '/**' || patternToTest === '**') {
    return `${negatedPrefix}${patternToTest}`;
  }
  const firstIndexOfSlash = patternToTest.indexOf('/');
  const matchEverywherePrefix = firstIndexOfSlash === -1 || firstIndexOfSlash === patternToTest.length - 1 ? '**/' : '';
  const patternWithoutLeadingSlash = firstIndexOfSlash === 0 ? patternToTest.slice(1) : patternToTest;
  // Escape `{` and `(` because in gitignore patterns they are just
  // literal characters without any specific syntactic meaning,
  // while in minimatch patterns they can form brace expansion or extglob syntax.
  //
  // For example, gitignore pattern `src/{a,b}.js` ignores file `src/{a,b}.js`.
  // But, the same minimatch pattern `src/{a,b}.js` ignores files `src/a.js` and `src/b.js`.
  // Minimatch pattern `src/\{a,b}.js` is equivalent to gitignore pattern `src/{a,b}.js`.
  const escapedPatternWithoutLeadingSlash = patternWithoutLeadingSlash.replaceAll(/(?=((?:\\.|[^{(])*))\1([{(])/guy, '$1\\$2');
  const matchInsideSuffix = patternToTest.endsWith('/**') ? '/*' : '';
  return `${negatedPrefix}${matchEverywherePrefix}${escapedPatternWithoutLeadingSlash}${matchInsideSuffix}`;
}
function workspacePatternToGlobPattern(workspace) {
  const {
    length
  } = workspace;
  if (!length) {
    return '';
  }
  // If the workspace ends with "/"
  if (workspace.charCodeAt(length - 1) === 47 /*'/'*/) {
    return `${workspace}/*/package.json`;
  }
  // If the workspace ends with "/**"
  if (workspace.charCodeAt(length - 1) === 42 /*'*'*/ && workspace.charCodeAt(length - 2) === 42 /*'*'*/ && workspace.charCodeAt(length - 3) === 47 /*'/'*/) {
    return `${workspace}/*/**/package.json`;
  }
  // Things like "packages/a" or "packages/*"
  return `${workspace}/package.json`;
}
function filterBySupportedScanFiles(filepaths, supportedFiles) {
  const patterns = getSupportedFilePatterns(supportedFiles);
  return filepaths.filter(p => vendor.micromatchExports.some(p, patterns));
}
function getSupportedFilePatterns(supportedFiles) {
  const patterns = [];
  for (const key of Object.keys(supportedFiles)) {
    const supported = supportedFiles[key];
    if (supported) {
      patterns.push(...Object.values(supported).map(p => `**/${p.pattern}`));
    }
  }
  return patterns;
}
async function globWithGitIgnore(patterns, options) {
  const {
    cwd = process.cwd(),
    socketConfig,
    ...additionalOptions
  } = {
    __proto__: null,
    ...options
  };
  const ignores = new Set(IGNORED_DIR_PATTERNS);
  const projectIgnorePaths = socketConfig?.projectIgnorePaths;
  if (Array.isArray(projectIgnorePaths)) {
    const ignorePatterns = ignoreFileLinesToGlobPatterns(projectIgnorePaths, path.join(cwd, '.gitignore'), cwd);
    for (const pattern of ignorePatterns) {
      ignores.add(pattern);
    }
  }
  const gitIgnoreStream = vendor.outExports.globStream(['**/.gitignore'], {
    absolute: true,
    cwd,
    ignore: DEFAULT_IGNORE_FOR_GIT_IGNORE
  });
  for await (const ignorePatterns of streams.transform(gitIgnoreStream, async filepath => ignoreFileToGlobPatterns((await fs.safeReadFile(filepath)) ?? '', filepath, cwd), {
    concurrency: 8
  })) {
    for (const p of ignorePatterns) {
      ignores.add(p);
    }
  }
  let hasNegatedPattern = false;
  for (const p of ignores) {
    if (p.charCodeAt(0) === 33 /*'!'*/) {
      hasNegatedPattern = true;
      break;
    }
  }
  const globOptions = {
    __proto__: null,
    absolute: true,
    cwd,
    dot: true,
    ignore: hasNegatedPattern ? globs.defaultIgnore : [...ignores],
    ...additionalOptions
  };
  if (!hasNegatedPattern) {
    return await vendor.outExports.glob(patterns, globOptions);
  }

  // Add support for negated "ignore" patterns which many globbing libraries,
  // including 'fast-glob', 'globby', and 'tinyglobby', lack support for.
  const filtered = [];
  const ig = vendor.ignoreExports().add([...ignores]);
  const stream = vendor.outExports.globStream(patterns, globOptions);
  for await (const p of stream) {
    // Note: the input files must be INSIDE the cwd. If you get strange looking
    // relative path errors here, most likely your path is outside the given cwd.
    const relPath = globOptions.absolute ? path.relative(cwd, p) : p;
    if (!ig.ignores(relPath)) {
      filtered.push(p);
    }
  }
  return filtered;
}
async function globWorkspace(agent, cwd = process.cwd()) {
  const workspaceGlobs = await getWorkspaceGlobs(agent, cwd);
  return workspaceGlobs.length ? await vendor.outExports.glob(workspaceGlobs, {
    absolute: true,
    cwd,
    ignore: globs.defaultIgnore
  }) : [];
}
function isReportSupportedFile(filepath, supportedFiles) {
  const patterns = getSupportedFilePatterns(supportedFiles);
  return vendor.micromatchExports.some(filepath, patterns);
}
function pathsToGlobPatterns(paths) {
  // TODO: Does not support `~/` paths.
  return paths.map(p => p === '.' || p === './' ? '**/*' : p);
}

function findBinPathDetailsSync(binName) {
  const rawBinPaths = bin.whichBinSync(binName, {
    all: true,
    nothrow: true
  }) ?? [];
  // whichBinSync may return a string when only one result is found, even with all: true.
  // This handles both the current published version and future versions.
  const binPaths = Array.isArray(rawBinPaths) ? rawBinPaths : typeof rawBinPaths === 'string' ? [rawBinPaths] : [];
  const {
    shadowBinPath
  } = constants.default;
  let shadowIndex = -1;
  let theBinPath;
  for (let i = 0, {
      length
    } = binPaths; i < length; i += 1) {
    const binPath = binPaths[i];
    // Skip our bin directory if it's in the front.
    if (path.dirname(binPath) === shadowBinPath) {
      shadowIndex = i;
    } else {
      theBinPath = bin.resolveBinPathSync(binPath);
      break;
    }
  }
  return {
    name: binName,
    path: theBinPath,
    shadowed: shadowIndex !== -1
  };
}
function findNpmDirPathSync(npmBinPath) {
  const {
    WIN32
  } = constants.default;
  let thePath = npmBinPath;
  while (true) {
    const libNmNpmPath = path.join(thePath, `lib/${constants.NODE_MODULES}/${constants.NPM}`);
    // mise, which uses opaque binaries, puts its npm bin in a path like:
    //   /Users/SomeUsername/.local/share/mise/installs/node/vX.X.X/bin/npm.
    // HOWEVER, the location of the npm install is:
    //   /Users/SomeUsername/.local/share/mise/installs/node/vX.X.X/lib/node_modules/npm.
    if (
    // Use existsSync here because statsSync, even with { throwIfNoEntry: false },
    // will throw an ENOTDIR error for paths like ./a-file-that-exists/a-directory-that-does-not.
    // See https://github.com/nodejs/node/issues/56993.
    fs.isDirSync(libNmNpmPath)) {
      thePath = libNmNpmPath;
    }
    const hasNmInCurrPath = fs.isDirSync(path.join(thePath, constants.NODE_MODULES));
    const hasNmInParentPath = !hasNmInCurrPath && fs.isDirSync(path.join(thePath, `../${constants.NODE_MODULES}`));
    if (
    // npm bin paths may look like:
    //   /usr/local/share/npm/bin/npm
    //   /Users/SomeUsername/.nvm/versions/node/vX.X.X/bin/npm
    //   C:\Users\SomeUsername\AppData\Roaming\npm\bin\npm.cmd
    // OR
    //   C:\Program Files\nodejs\npm.cmd
    //
    // In practically all cases the npm path contains a node_modules folder:
    //   /usr/local/share/npm/bin/npm/node_modules
    //   C:\Program Files\nodejs\node_modules
    (hasNmInCurrPath ||
    // In some bespoke cases the node_modules folder is in the parent directory.
    hasNmInParentPath) && (
    // Optimistically look for the default location.
    path.basename(thePath) === constants.NPM ||
    // Chocolatey installs npm bins in the same directory as node bins.
    WIN32 && fs$1.existsSync(path.join(thePath, `${constants.NPM}.cmd`)))) {
      return hasNmInParentPath ? path.dirname(thePath) : thePath;
    }
    const parent = path.dirname(thePath);
    if (parent === thePath) {
      return undefined;
    }
    thePath = parent;
  }
}
async function getPackageFilesForScan(inputPaths, supportedFiles, options) {
  const {
    config: socketConfig,
    cwd = process.cwd()
  } = {
    __proto__: null,
    ...options
  };
  const filepaths = await globWithGitIgnore(pathsToGlobPatterns(inputPaths), {
    cwd,
    socketConfig
  });
  return filterBySupportedScanFiles(filepaths, supportedFiles);
}

function exitWithBinPathError$2(binName) {
  logger.logger.fail(`Socket unable to locate ${binName}; ensure it is available in the PATH environment variable`);
  // The exit code 127 indicates that the command or binary being executed
  // could not be found.
  // eslint-disable-next-line n/no-process-exit
  process.exit(127);
  // This line is never reached in production, but helps tests.
  throw new Error('process.exit called');
}
let _yarnBinPath;
function getYarnBinPath() {
  if (_yarnBinPath === undefined) {
    _yarnBinPath = getYarnBinPathDetails().path;
    if (!_yarnBinPath) {
      exitWithBinPathError$2(constants.YARN);
    }
  }
  return _yarnBinPath;
}
let _yarnBinPathDetails;
function getYarnBinPathDetails() {
  if (_yarnBinPathDetails === undefined) {
    _yarnBinPathDetails = findBinPathDetailsSync(constants.YARN);
  }
  return _yarnBinPathDetails;
}
function isYarnBinPathShadowed() {
  return getYarnBinPathDetails().shadowed;
}

let _isYarnBerry;
function isYarnBerry() {
  if (_isYarnBerry === undefined) {
    try {
      const yarnBinPath = getYarnBinPath();
      const result = spawn.spawnSync(yarnBinPath, [constants.FLAG_VERSION], {
        encoding: constants.UTF8,
        // On Windows, yarn is often a .cmd file that requires shell execution.
        // The spawn function from @socketsecurity/registry will handle this properly
        // when shell is true.
        shell: constants.default.WIN32
      });
      if (result.status === 0 && result.stdout) {
        const version = result.stdout;
        // Yarn Berry starts from version 2.x
        const majorVersion = parseInt(version.split('.')[0], 10);
        _isYarnBerry = majorVersion >= 2;
      } else {
        _isYarnBerry = false;
      }
    } catch {
      _isYarnBerry = false;
    }
  }
  return _isYarnBerry;
}

/**
 * DLX execution utilities for Socket CLI.
 * Manages package execution via npx/pnpm dlx/yarn dlx commands.
 *
 * Key Functions:
 * - spawnCdxgenDlx: Execute CycloneDX generator via dlx
 * - spawnCoanaDlx: Execute Coana CLI tool via dlx
 * - spawnDlx: Execute packages using dlx-style commands
 * - spawnSynpDlx: Execute Synp converter via dlx
 *
 * Package Manager Detection:
 * - Auto-detects npm, pnpm, or yarn based on lockfiles
 * - Supports force-refresh and silent execution modes
 *
 * Integration:
 * - Works with shadow binaries for security scanning
 * - Handles version pinning and cache management
 * - Configures environment for third-party tools
 */

const require$2 = require$$5.createRequire((typeof document === 'undefined' ? require$$0.pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('utils.js', document.baseURI).href)));
const {
  PACKAGE_LOCK_JSON,
  PNPM_LOCK_YAML,
  YARN_LOCK
} = constants.default;
/**
 * Regex to check if a version string contains range operators.
 * Matches any version with range operators: ~, ^, >, <, =, x, X, *, spaces, or ||.
 */
const rangeOperatorsRegExp = /[~^><=xX* ]|\|\|/;

/**
 * Spawns a package using dlx-style execution (npx/pnpm dlx/yarn dlx).
 * Automatically detects the appropriate package manager if not specified.
 * Uses force/update flags to ensure the latest version within the range is fetched.
 */
async function spawnDlx(packageSpec, args, options, spawnExtra) {
  // If version is not pinned exactly, default to force and silent for better UX.
  const isNotPinned = rangeOperatorsRegExp.test(packageSpec.version);
  const {
    agent,
    force = false,
    silent = isNotPinned,
    ...shadowOptions
  } = options ?? {};
  let finalShadowOptions = shadowOptions;
  let pm = agent;

  // Auto-detect package manager if not specified.
  if (!pm) {
    const pnpmLockPath = await findUp(PNPM_LOCK_YAML, {
      onlyFiles: true
    });
    const yarnLockPath = pnpmLockPath ? undefined : await findUp(YARN_LOCK, {
      onlyFiles: true
    });
    const npmLockPath = pnpmLockPath || yarnLockPath ? undefined : await findUp(PACKAGE_LOCK_JSON, {
      onlyFiles: true
    });
    if (pnpmLockPath) {
      pm = constants.PNPM;
    } else if (yarnLockPath) {
      pm = constants.YARN;
    } else if (npmLockPath) {
      pm = constants.NPM;
    } else {
      // Default to npm if no lockfile found.
      pm = constants.NPM;
    }
  }
  const packageString = `${packageSpec.name}@${packageSpec.version}`;

  // Build command args based on package manager.
  let spawnArgs;
  if (pm === constants.PNPM) {
    spawnArgs = ['dlx'];
    if (force) {
      // For pnpm, set dlx-cache-max-age to 0 via env to force fresh download.
      // This ensures we always get the latest version within the range.
      finalShadowOptions = {
        ...finalShadowOptions,
        env: {
          ...require$$11.getOwn(finalShadowOptions, 'env'),
          // Set dlx cache max age to 0 minutes to bypass cache.
          // The npm_config_ prefix is how pnpm reads config from environment variables.
          // See: https://pnpm.io/npmrc#settings
          npm_config_dlx_cache_max_age: '0'
        }
      };
    }
    if (silent) {
      spawnArgs.push(constants.FLAG_SILENT);
    }
    spawnArgs.push(packageString, ...args);
    const shadowPnpmBin = /*@__PURE__*/require$2(constants.default.shadowPnpmBinPath);
    return await shadowPnpmBin(spawnArgs, finalShadowOptions, spawnExtra);
  } else if (pm === constants.YARN && isYarnBerry()) {
    spawnArgs = ['dlx'];
    // Yarn dlx runs in a temporary environment by design and should always fetch fresh.
    if (silent) {
      spawnArgs.push(constants.FLAG_QUIET);
    }
    spawnArgs.push(packageString, ...args);
    const shadowYarnBin = /*@__PURE__*/require$2(constants.default.shadowYarnBinPath);
    return await shadowYarnBin(spawnArgs, finalShadowOptions, spawnExtra);
  } else {
    // Use npm exec/npx.
    // For consistency, we'll use npx which is more commonly used for one-off execution.
    spawnArgs = ['--yes'];
    if (force) {
      // Use --force to bypass cache and get latest within range.
      spawnArgs.push('--force');
    }
    if (silent) {
      spawnArgs.push(constants.FLAG_SILENT);
    }
    spawnArgs.push(packageString, ...args);
    const shadowNpxBin = /*@__PURE__*/require$2(constants.default.shadowNpxBinPath);
    return await shadowNpxBin(spawnArgs, finalShadowOptions, spawnExtra);
  }
}

/**
 * Helper to spawn coana with dlx.
 * Automatically uses force and silent when version is not pinned exactly.
 * Returns a CResult with stdout extraction for backward compatibility.
 */
async function spawnCoanaDlx(args, orgSlug, options, spawnExtra) {
  const {
    env: spawnEnv,
    ipc,
    ...dlxOptions
  } = {
    __proto__: null,
    ...options
  };
  const mixinsEnv = {
    SOCKET_CLI_VERSION: constants.default.ENV.INLINED_SOCKET_CLI_VERSION
  };
  const defaultApiToken = getDefaultApiToken();
  if (defaultApiToken) {
    mixinsEnv['SOCKET_CLI_API_TOKEN'] = defaultApiToken;
  }
  if (orgSlug) {
    mixinsEnv['SOCKET_ORG_SLUG'] = orgSlug;
  } else {
    const orgSlugCResult = await getDefaultOrgSlug();
    if (orgSlugCResult.ok) {
      mixinsEnv['SOCKET_ORG_SLUG'] = orgSlugCResult.data;
    }
  }
  const proxyUrl = getDefaultProxyUrl();
  if (proxyUrl) {
    mixinsEnv['SOCKET_CLI_API_PROXY'] = proxyUrl;
  }
  try {
    const result = await spawnDlx({
      name: '@coana-tech/cli',
      version: `~${constants.default.ENV.INLINED_SOCKET_CLI_COANA_TECH_CLI_VERSION}`
    }, args, {
      force: true,
      silent: true,
      ...dlxOptions,
      env: {
        ...process.env,
        ...constants.default.processEnv,
        ...mixinsEnv,
        ...spawnEnv
      },
      ipc: {
        [constants.default.SOCKET_CLI_SHADOW_ACCEPT_RISKS]: true,
        [constants.default.SOCKET_CLI_SHADOW_API_TOKEN]: constants.default.SOCKET_PUBLIC_API_TOKEN,
        [constants.default.SOCKET_CLI_SHADOW_SILENT]: true,
        ...ipc
      }
    }, spawnExtra);
    const output = await result.spawnPromise;
    return {
      ok: true,
      data: output.stdout
    };
  } catch (e) {
    const stderr = e?.stderr;
    const cause = getErrorCause(e);
    const message = stderr || cause;
    return {
      ok: false,
      data: e,
      message
    };
  }
}

/**
 * Helper to spawn cdxgen with dlx.
 */
async function spawnCdxgenDlx(args, options, spawnExtra) {
  return await spawnDlx({
    name: '@cyclonedx/cdxgen',
    version: `${constants.default.ENV.INLINED_SOCKET_CLI_CYCLONEDX_CDXGEN_VERSION}`
  }, args, {
    force: false,
    silent: true,
    ...options
  }, spawnExtra);
}

/**
 * Helper to spawn synp with dlx.
 */
async function spawnSynpDlx(args, options, spawnExtra) {
  return await spawnDlx({
    name: 'synp',
    version: `${constants.default.ENV.INLINED_SOCKET_CLI_SYNP_VERSION}`
  }, args, {
    force: false,
    silent: true,
    ...options
  }, spawnExtra);
}

function getEnterpriseOrgs(orgs) {
  return orgs.filter(o => o.plan === 'enterprise');
}
function getOrgSlugs(orgs) {
  return orgs.map(o => o.slug);
}
function hasEnterpriseOrgPlan(orgs) {
  return orgs.some(o => o.plan === 'enterprise');
}

/**
 * Socket JSON utilities for Socket CLI.
 * Manages .socket/socket.json configuration and scan metadata.
 *
 * Key Functions:
 * - loadDotSocketDirectory: Load .socket directory configuration
 * - saveSocketJson: Persist scan configuration to .socket/socket.json
 * - validateSocketJson: Validate socket.json structure
 *
 * File Structure:
 * - Contains scan metadata and configuration
 * - Stores scan IDs and repository information
 * - Tracks CLI version and scan timestamps
 *
 * Directory Management:
 * - Creates .socket directory as needed
 * - Handles nested directory structures
 * - Supports both read and write operations
 */

function readOrDefaultSocketJson(cwd) {
  const jsonCResult = readSocketJsonSync(cwd, true);
  return jsonCResult.ok ? jsonCResult.data :
  // This should be unreachable but it makes TS happy.
  getDefaultSocketJson();
}
async function findSocketJsonUp(cwd) {
  return await findUp(constants.SOCKET_JSON, {
    onlyFiles: true,
    cwd
  });
}
async function readOrDefaultSocketJsonUp(cwd) {
  const socketJsonPath = await findSocketJsonUp(cwd);
  if (socketJsonPath) {
    const socketJsonDir = path.dirname(socketJsonPath);
    const jsonCResult = readSocketJsonSync(socketJsonDir, true);
    return jsonCResult.ok ? jsonCResult.data : getDefaultSocketJson();
  }
  return getDefaultSocketJson();
}
function getDefaultSocketJson() {
  return {
    ' _____         _       _     ': `Local config file for Socket CLI tool ( ${constants.SOCKET_WEBSITE_URL}/npm/package/${constants.SOCKET_JSON.replace('.json', '')} ), to work with ${constants.SOCKET_WEBSITE_URL}`,
    '|   __|___ ___| |_ ___| |_   ': '     The config in this file is used to set as defaults for flags or command args when using the CLI',
    "|__   | . |  _| '_| -_|  _|  ": '     in this dir, often a repo root. You can choose commit or .ignore this file, both works.',
    '|_____|___|___|_,_|___|_|.dev': `Warning: This file may be overwritten without warning by \`${constants.SOCKET_JSON.replace('.json', '')} manifest setup\` or other commands`,
    version: 1
  };
}
function readSocketJsonSync(cwd, defaultOnError = false) {
  const sockJsonPath = path.join(cwd, constants.SOCKET_JSON);
  if (!fs$1.existsSync(sockJsonPath)) {
    require$$9.debugFn('notice', `miss: ${constants.SOCKET_JSON} not found at ${cwd}`);
    return {
      ok: true,
      data: getDefaultSocketJson()
    };
  }
  let jsonContent = null;
  try {
    jsonContent = fs$1.readFileSync(sockJsonPath, 'utf8');
  } catch (e) {
    if (defaultOnError) {
      logger.logger.warn(`Failed to read ${constants.SOCKET_JSON}, using default`);
      require$$9.debugFn('warn', `Failed to read ${constants.SOCKET_JSON} sync`);
      require$$9.debugDir('warn', e);
      return {
        ok: true,
        data: getDefaultSocketJson()
      };
    }
    const cause = formatErrorWithDetail(`An error occurred while trying to read ${constants.SOCKET_JSON}`, e);
    require$$9.debugFn('error', `Failed to read ${constants.SOCKET_JSON} sync`);
    require$$9.debugDir('error', e);
    return {
      ok: false,
      message: `Failed to read ${constants.SOCKET_JSON}`,
      cause
    };
  }
  let jsonObj;
  try {
    jsonObj = JSON.parse(jsonContent);
  } catch (e) {
    require$$9.debugFn('error', `Failed to parse ${constants.SOCKET_JSON} as JSON (sync)`);
    require$$9.debugDir('inspect', {
      jsonContent
    });
    require$$9.debugDir('error', e);
    if (defaultOnError) {
      logger.logger.warn(`Failed to parse ${constants.SOCKET_JSON}, using default`);
      return {
        ok: true,
        data: getDefaultSocketJson()
      };
    }
    return {
      ok: false,
      message: `Failed to parse ${constants.SOCKET_JSON}`,
      cause: `${constants.SOCKET_JSON} does not contain valid JSON, please verify`
    };
  }
  if (!jsonObj) {
    logger.logger.warn('Warning: file contents was empty, using default');
    return {
      ok: true,
      data: getDefaultSocketJson()
    };
  }

  // TODO: Do we need to validate? All properties are optional so code will have
  // to check every step of the way regardless.
  return {
    ok: true,
    data: jsonObj
  };
}
async function writeSocketJson(cwd, sockJson) {
  let jsonContent = '';
  try {
    jsonContent = JSON.stringify(sockJson, null, 2);
  } catch (e) {
    require$$9.debugFn('error', `Failed to serialize ${constants.SOCKET_JSON} to JSON`);
    require$$9.debugDir('inspect', {
      sockJson
    });
    require$$9.debugDir('error', e);
    return {
      ok: false,
      message: 'Failed to serialize to JSON',
      cause: `There was an unexpected problem converting the ${constants.SOCKET_JSON} object to a JSON string. Unable to store it.`
    };
  }
  const filepath = path.join(cwd, constants.SOCKET_JSON);
  await fs$1.promises.writeFile(filepath, `${jsonContent}\n`, 'utf8');
  return {
    ok: true,
    data: undefined
  };
}

/**
 * GitHub utilities for Socket CLI.
 * Provides GitHub API integration for repository operations and GHSA vulnerability data.
 *
 * Authentication:
 * - getGitHubToken: Retrieve GitHub token from env/git config
 * - getOctokit: Get authenticated Octokit instance
 * - getOctokitGraphql: Get authenticated GraphQL client
 *
 * Caching:
 * - 5-minute TTL for API responses
 * - Automatic cache invalidation
 * - Persistent cache in node_modules/.cache
 *
 * GHSA Operations:
 * - cacheFetch: Cache API responses with TTL
 * - fetchGhsaDetails: Fetch GitHub Security Advisory details
 * - getGhsaUrl: Generate GHSA advisory URL
 * - readCache/writeCache: Persistent cache operations
 *
 * Repository Operations:
 * - GraphQL queries for complex operations
 * - Integration with Octokit REST API
 * - Support for GitHub Actions environment variables
 */

async function readCache(key,
// 5 minute in milliseconds time to live (TTL).
ttlMs = 5 * 60 * 1000) {
  const cacheJsonPath = path.join(constants.default.githubCachePath, `${key}.json`);
  const stat = fs.safeStatsSync(cacheJsonPath);
  if (stat) {
    const isExpired = Date.now() - stat.mtimeMs > ttlMs;
    if (!isExpired) {
      return await fs.readJson(cacheJsonPath);
    }
  }
  return undefined;
}
async function writeCache(key, data) {
  const {
    githubCachePath
  } = constants.default;
  const cacheJsonPath = path.join(githubCachePath, `${key}.json`);
  if (!fs$1.existsSync(githubCachePath)) {
    await fs$1.promises.mkdir(githubCachePath, {
      recursive: true
    });
  }
  await fs.writeJson(cacheJsonPath, data);
}
async function cacheFetch(key, fetcher, ttlMs) {
  // Optionally disable cache.
  if (constants.default.ENV.DISABLE_GITHUB_CACHE) {
    return await fetcher();
  }
  let data = await readCache(key, ttlMs);
  if (!data) {
    data = await fetcher();
    await writeCache(key, data);
  }
  return data;
}
async function fetchGhsaDetails(ids) {
  const results = new Map();
  if (!ids.length) {
    return results;
  }
  const octokitGraphql = getOctokitGraphql();
  try {
    const gqlCacheKey = `${ids.join('-')}-graphql-snapshot`;
    const aliases = ids.map((id, index) => `advisory${index}: securityAdvisory(ghsaId: "${id}") {
        ghsaId
        summary
        severity
        publishedAt
        withdrawnAt
        vulnerabilities(first: 10) {
          nodes {
            package {
              ecosystem
              name
            }
            vulnerableVersionRange
          }
        }
      }`).join('\n');
    const gqlResp = await cacheFetch(gqlCacheKey, () => octokitGraphql(`
        query {
          ${aliases}
        }
      `));
    for (let i = 0, {
        length
      } = ids; i < length; i += 1) {
      const id = ids[i];
      const advisoryKey = `advisory${i}`;
      const advisory = gqlResp?.[advisoryKey];
      if (advisory && advisory.ghsaId) {
        results.set(id, advisory);
      } else {
        require$$9.debugFn('notice', `miss: no advisory found for ${id}`);
      }
    }
  } catch (e) {
    require$$9.debugFn('error', formatErrorWithDetail('Failed to fetch GHSA details', e));
    require$$9.debugDir('error', e);
  }
  return results;
}
let _octokit;
function getOctokit() {
  if (_octokit === undefined) {
    const {
      SOCKET_CLI_GITHUB_TOKEN
    } = constants.default.ENV;
    if (!SOCKET_CLI_GITHUB_TOKEN) {
      require$$9.debugFn('notice', 'miss: SOCKET_CLI_GITHUB_TOKEN env var');
    }
    const octokitOptions = {
      auth: SOCKET_CLI_GITHUB_TOKEN,
      baseUrl: constants.default.ENV.GITHUB_API_URL
    };
    require$$9.debugDir('inspect', {
      octokitOptions
    });
    _octokit = new vendor.Octokit(octokitOptions);
  }
  return _octokit;
}
let _octokitGraphql;
function getOctokitGraphql() {
  if (!_octokitGraphql) {
    const {
      SOCKET_CLI_GITHUB_TOKEN
    } = constants.default.ENV;
    if (!SOCKET_CLI_GITHUB_TOKEN) {
      require$$9.debugFn('notice', 'miss: SOCKET_CLI_GITHUB_TOKEN env var');
    }
    _octokitGraphql = vendor.graphql2.defaults({
      headers: {
        authorization: `token ${SOCKET_CLI_GITHUB_TOKEN}`
      }
    });
  }
  return _octokitGraphql;
}
async function enablePrAutoMerge({
  node_id: prId
}) {
  const octokitGraphql = getOctokitGraphql();
  try {
    const gqlResp = await octokitGraphql(`
      mutation EnableAutoMerge($pullRequestId: ID!) {
        enablePullRequestAutoMerge(input: {
          pullRequestId: $pullRequestId,
          mergeMethod: SQUASH
        }) {
          pullRequest {
            number
          }
        }
      }`, {
      pullRequestId: prId
    });
    const respPrNumber = gqlResp?.enablePullRequestAutoMerge?.pullRequest?.number;
    if (respPrNumber) {
      return {
        enabled: true
      };
    }
  } catch (e) {
    if (e instanceof vendor.GraphqlResponseError && Array.isArray(e.errors) && e.errors.length) {
      const details = e.errors.map(({
        message: m
      }) => m.trim());
      return {
        enabled: false,
        details
      };
    }
  }
  return {
    enabled: false
  };
}
async function setGitRemoteGithubRepoUrl(owner, repo, token, cwd = process.cwd()) {
  const {
    GITHUB_SERVER_URL
  } = constants.default.ENV;
  const urlObj = require$$13.parseUrl(GITHUB_SERVER_URL);
  const host = urlObj?.host;
  if (!host) {
    require$$9.debugFn('error', 'invalid: GITHUB_SERVER_URL env var');
    require$$9.debugDir('inspect', {
      GITHUB_SERVER_URL
    });
    return false;
  }
  const url = `https://x-access-token:${token}@${host}/${owner}/${repo}`;
  const stdioIgnoreOptions = {
    cwd,
    stdio: require$$9.isDebug('stdio') ? 'inherit' : 'ignore'
  };
  const quotedCmd = `\`git remote set-url origin ${url}\``;
  require$$9.debugFn('stdio', `spawn: ${quotedCmd}`);
  try {
    await spawn.spawn('git', ['remote', 'set-url', 'origin', url], stdioIgnoreOptions);
    return true;
  } catch (e) {
    require$$9.debugFn('error', `Git command failed: ${quotedCmd}`);
    require$$9.debugDir('inspect', {
      cmd: quotedCmd
    });
    require$$9.debugDir('error', e);
  }
  return false;
}

/**
 * Command-line utilities for Socket CLI.
 * Handles argument parsing, flag processing, and command formatting.
 *
 * Argument Handling:
 * - Handles both long (--flag) and short (-f) formats
 * - Preserves special characters and escaping
 * - Properly quotes arguments containing spaces
 *
 * Command Names:
 * - commandNameFromCamel: Convert camelCase to kebab-case command names
 * - commandNameFromKebab: Convert kebab-case to camelCase
 *
 * Flag Processing:
 * - cmdFlagsToString: Format arguments for display with proper escaping
 * - cmdPrefixMessage: Generate command prefix message
 * - stripConfigFlags: Remove --config flags from argument list
 * - stripDebugFlags: Remove debug-related flags
 * - stripHelpFlags: Remove help flags (-h, --help)
 */

const helpFlags = new Set([constants.FLAG_HELP, '-h']);

/**
 * Convert flag values to array format for processing.
 */
function cmdFlagValueToArray(value) {
  if (typeof value === 'string') {
    return value.trim().split(/, */).filter(Boolean);
  }
  if (Array.isArray(value)) {
    return value.flatMap(cmdFlagValueToArray);
  }
  return [];
}

/**
 * Convert command arguments to a properly formatted string representation.
 */
function cmdFlagsToString(args) {
  const result = [];
  for (let i = 0, {
      length
    } = args; i < length; i += 1) {
    const arg = args[i].trim();
    if (arg.startsWith('--')) {
      const nextArg = i + 1 < length ? args[i + 1].trim() : undefined;
      // Check if the next item exists and is NOT another flag.
      if (nextArg && !nextArg.startsWith('--') && !nextArg.startsWith('-')) {
        result.push(`${arg}=${nextArg}`);
        i += 1;
      } else {
        result.push(arg);
      }
    } else {
      // Include non-flag arguments (commands, package names, etc.).
      result.push(arg);
    }
  }
  return result.join(' ');
}

/**
 * Add command name prefix to message text.
 */
function cmdPrefixMessage(cmdName, text) {
  const cmdPrefix = cmdName ? `${cmdName}: ` : '';
  return `${cmdPrefix}${text}`;
}

/**
 * Filter out Socket flags from argv before passing to subcommands.
 */
function filterFlags(argv, flagsToFilter, exceptions) {
  const filtered = [];

  // Build set of flags to filter from the provided flag objects.
  const flagsToFilterSet = new Set();
  const flagsWithValueSet = new Set();
  for (const [flagName, flag] of Object.entries(flagsToFilter)) {
    const longFlag = `--${camelToKebab(flagName)}`;
    // Special case for negated booleans.
    if (flagName === 'spinner' || flagName === 'banner') {
      flagsToFilterSet.add(`--no-${flagName}`);
    } else {
      flagsToFilterSet.add(longFlag);
    }
    if (flag?.shortFlag) {
      flagsToFilterSet.add(`-${flag.shortFlag}`);
    }
    // Track flags that take values.
    if (flag.type !== 'boolean') {
      flagsWithValueSet.add(longFlag);
      if (flag?.shortFlag) {
        flagsWithValueSet.add(`-${flag.shortFlag}`);
      }
    }
  }
  for (let i = 0, {
      length
    } = argv; i < length; i += 1) {
    const arg = argv[i];
    // Check if this flag should be kept as an exception.
    if (exceptions?.includes(arg)) {
      filtered.push(arg);
      // Handle flags that take values.
      if (flagsWithValueSet.has(arg)) {
        // Include the next argument (the flag value).
        i += 1;
        if (i < length) {
          filtered.push(argv[i]);
        }
      }
    } else if (flagsToFilterSet.has(arg)) {
      // Skip flags that take values.
      if (flagsWithValueSet.has(arg)) {
        // Skip the next argument (the flag value).
        i += 1;
      }
      // Skip boolean flags (no additional argument to skip).
    } else if (arg && Array.from(flagsWithValueSet).some(flag => arg.startsWith(`${flag}=`))) {
      // Skip --flag=value format for Socket flags unless it's an exception.
      if (exceptions?.some(exc => arg.startsWith(`${exc}=`))) {
        filtered.push(arg);
      }
      // Otherwise skip it.
    } else {
      filtered.push(arg);
    }
  }
  return filtered;
}

/**
 * Check if command is an add command (adds new dependencies).
 * Supported by: pnpm, yarn.
 * Note: npm uses 'install' with package names instead of 'add'.
 */
function isAddCommand(command) {
  return command === 'add';
}

/**
 * Check if argument is a help flag.
 */
function isHelpFlag(cmdArg) {
  return helpFlags.has(cmdArg);
}

/**
 * Check if pnpm command requires lockfile scanning.
 * pnpm uses: install, i, update, up
 */
function isPnpmLockfileScanCommand(command) {
  return command === 'install' || command === 'i' || command === 'update' || command === 'up';
}

/**
 * Converts CVE IDs to GHSA IDs using GitHub API.
 */
async function convertCveToGhsa(cveId) {
  try {
    const cacheKey = `cve-to-ghsa-${cveId}`;
    const octokit = getOctokit();
    const response = await cacheFetch(cacheKey, () => octokit.rest.securityAdvisories.listGlobalAdvisories({
      cve_id: cveId,
      per_page: 1
    }));
    if (!response.data.length) {
      return {
        ok: false,
        message: `No GHSA found for CVE ${cveId}`
      };
    }
    return {
      ok: true,
      data: response.data[0].ghsa_id
    };
  } catch (e) {
    return {
      ok: false,
      message: `Failed to convert CVE to GHSA: ${getErrorCause(e)}`
    };
  }
}

const PURL_TO_GITHUB_ECOSYSTEM_MAPPING = {
  __proto__: null,
  // GitHub Advisory Database supported ecosystems
  cargo: 'rust',
  composer: 'composer',
  gem: 'rubygems',
  go: 'go',
  golang: 'go',
  maven: 'maven',
  npm: 'npm',
  nuget: 'nuget',
  pypi: 'pip',
  swift: 'swift'
};

/**
 * Converts PURL to GHSA IDs using GitHub API.
 */
async function convertPurlToGhsas(purl) {
  try {
    const purlObj = getPurlObject(purl, {
      throws: false
    });
    if (!purlObj) {
      return {
        ok: false,
        message: `Invalid PURL format: ${purl}`
      };
    }
    const {
      name,
      type: ecosystem,
      version
    } = purlObj;

    // Map PURL ecosystem to GitHub ecosystem.
    const githubEcosystem = PURL_TO_GITHUB_ECOSYSTEM_MAPPING[ecosystem];
    if (!githubEcosystem) {
      return {
        ok: false,
        message: `Unsupported PURL ecosystem: ${ecosystem}`
      };
    }

    // Search for advisories affecting this package.
    const cacheKey = `purl-to-ghsa-${ecosystem}-${name}-${version || constants.LATEST}`;
    const octokit = getOctokit();
    const affects = version ? `${name}@${version}` : name;
    const response = await cacheFetch(cacheKey, () => octokit.rest.securityAdvisories.listGlobalAdvisories({
      ecosystem: githubEcosystem,
      affects
    }));
    return {
      ok: true,
      data: response.data.map(a => a.ghsa_id)
    };
  } catch (e) {
    return {
      ok: false,
      message: `Failed to convert PURL to GHSA: ${getErrorCause(e)}`
    };
  }
}

const RangeStyles = ['pin', 'preserve'];
function getMajor(version) {
  try {
    const coerced = vendor.semverExports.coerce(version);
    return coerced ? vendor.semverExports.major(coerced) : undefined;
  } catch {}
  return undefined;
}

const COMPLETION_CMD_PREFIX = 'complete -F _socket_completion';
function getCompletionSourcingCommand() {
  // Note: this is exported to distPath in .config/rollup.dist.config.mjs
  const completionScriptExportPath = path.join(constants.default.distPath, 'socket-completion.bash');
  if (!fs$1.existsSync(completionScriptExportPath)) {
    return {
      ok: false,
      message: 'Tab Completion script not found',
      cause: `Expected to find completion script at \`${completionScriptExportPath}\` but it was not there`
    };
  }
  return {
    ok: true,
    data: `source ${completionScriptExportPath}`
  };
}
function getBashrcDetails(targetCommandName) {
  const sourcingCommand = getCompletionSourcingCommand();
  if (!sourcingCommand.ok) {
    return sourcingCommand;
  }
  const {
    socketAppDataPath
  } = constants.default;
  if (!socketAppDataPath) {
    return {
      ok: false,
      message: 'Could not determine config directory',
      cause: 'Failed to get config path'
    };
  }

  // _socket_completion is the function defined in our completion bash script
  const completionCommand = `${COMPLETION_CMD_PREFIX} ${targetCommandName}`;

  // Location of completion script in config after installing
  const completionScriptPath = path.join(path.dirname(socketAppDataPath), 'completion', 'socket-completion.bash');
  const bashrcContent = `# Socket CLI completion for "${targetCommandName}"
if [ -f "${completionScriptPath}" ]; then
    # Load the tab completion script
    source "${completionScriptPath}"
    # Tell bash to use this function for tab completion of this function
    ${completionCommand}
fi
`;
  return {
    ok: true,
    data: {
      sourcingCommand: sourcingCommand.data,
      completionCommand,
      toAddToBashrc: bashrcContent,
      targetName: targetCommandName,
      targetPath: completionScriptPath
    }
  };
}

/**
 * Safe wrapper for npm-package-arg that doesn't throw.
 * Returns undefined if parsing fails.
 */
function safeNpa$1(...args) {
  try {
    return Reflect.apply(vendor.npaExports, undefined, args);
  } catch {}
  return undefined;
}

function exitWithBinPathError$1(binName) {
  logger.logger.fail(`Socket unable to locate ${binName}; ensure it is available in the PATH environment variable`);
  // The exit code 127 indicates that the command or binary being executed
  // could not be found.
  // eslint-disable-next-line n/no-process-exit
  process.exit(127);
  // This line is never reached in production, but helps tests.
  throw new Error('process.exit called');
}
let _npmBinPath;
function getNpmBinPath() {
  if (_npmBinPath === undefined) {
    _npmBinPath = getNpmBinPathDetails().path;
    if (!_npmBinPath) {
      exitWithBinPathError$1(constants.NPM);
    }
  }
  return _npmBinPath;
}
let _npmBinPathDetails;
function getNpmBinPathDetails() {
  if (_npmBinPathDetails === undefined) {
    _npmBinPathDetails = findBinPathDetailsSync(constants.NPM);
  }
  return _npmBinPathDetails;
}
let _npmDirPath;
function getNpmDirPath() {
  if (_npmDirPath === undefined) {
    const npmBinPath = getNpmBinPath();
    _npmDirPath = npmBinPath ? findNpmDirPathSync(npmBinPath) : undefined;
    if (!_npmDirPath) {
      _npmDirPath = constants.default.ENV.SOCKET_CLI_NPM_PATH || undefined;
    }
    if (!_npmDirPath) {
      let message = 'Unable to find npm CLI install directory.';
      if (npmBinPath) {
        message += `\nSearched parent directories of ${path.dirname(npmBinPath)}.`;
      }
      message += '\n\nThis is may be a bug with socket-npm related to changes to the npm CLI.';
      message += `\nPlease report to ${constants.default.SOCKET_CLI_ISSUES_URL}.`;
      logger.logger.fail(message);
      // The exit code 127 indicates that the command or binary being executed
      // could not be found.
      // eslint-disable-next-line n/no-process-exit
      process.exit(127);
      // This line is never reached in production, but helps tests.
      throw new Error('process.exit called');
    }
  }
  return _npmDirPath;
}
let _npmRequire;
function getNpmRequire() {
  if (_npmRequire === undefined) {
    const npmDirPath = getNpmDirPath();
    const npmNmPath = path.join(npmDirPath, `${constants.NODE_MODULES}/npm`);
    _npmRequire = require$$5.createRequire(path.join(fs$1.existsSync(npmNmPath) ? npmNmPath : npmDirPath, '<dummy-basename>'));
  }
  return _npmRequire;
}
let _npxBinPath;
function getNpxBinPath() {
  if (_npxBinPath === undefined) {
    _npxBinPath = getNpxBinPathDetails().path;
    if (!_npxBinPath) {
      exitWithBinPathError$1('npx');
    }
  }
  return _npxBinPath;
}
let _npxBinPathDetails;
function getNpxBinPathDetails() {
  if (_npxBinPathDetails === undefined) {
    _npxBinPathDetails = findBinPathDetailsSync('npx');
  }
  return _npxBinPathDetails;
}
function isNpmBinPathShadowed() {
  return getNpmBinPathDetails().shadowed;
}
function isNpxBinPathShadowed() {
  return getNpxBinPathDetails().shadowed;
}

function shadowNpmInstall(options) {
  const {
    agentExecPath = getNpmBinPath(),
    args = [],
    ipc,
    spinner,
    ...spawnOpts
  } = {
    __proto__: null,
    ...options
  };
  const useDebug = require$$9.isDebug('stdio');
  const terminatorPos = args.indexOf('--');
  const rawBinArgs = terminatorPos === -1 ? args : args.slice(0, terminatorPos);
  const binArgs = rawBinArgs.filter(a => !agent.isNpmAuditFlag(a) && !agent.isNpmFundFlag(a) && !agent.isNpmProgressFlag(a));
  const otherArgs = terminatorPos === -1 ? [] : args.slice(terminatorPos);
  const progressArg = rawBinArgs.findLast(agent.isNpmProgressFlag) !== '--no-progress';
  const isSilent = !useDebug && !binArgs.some(agent.isNpmLoglevelFlag);
  const logLevelArgs = isSilent ? [constants.FLAG_LOGLEVEL, 'silent'] : [];
  const useIpc = require$$11.isObject(ipc);

  // Include 'ipc' in the spawnOpts.stdio when an options.ipc object is provided.
  // See https://github.com/nodejs/node/blob/v23.6.0/lib/child_process.js#L161-L166
  // and https://github.com/nodejs/node/blob/v23.6.0/lib/internal/child_process.js#L238.
  let stdio = require$$11.getOwn(spawnOpts, 'stdio');
  if (typeof stdio === 'string') {
    stdio = useIpc ? [stdio, stdio, stdio, 'ipc'] : [stdio, stdio, stdio];
  } else if (Array.isArray(stdio)) {
    if (useIpc && !stdio.includes('ipc')) {
      stdio = stdio.concat('ipc');
    }
  } else {
    stdio = useIpc ? ['pipe', 'pipe', 'pipe', 'ipc'] : 'pipe';
  }
  const spawnPromise = spawn.spawn(constants.default.execPath, [...constants.default.nodeNoWarningsFlags, ...constants.default.nodeDebugFlags, ...constants.default.nodeHardenFlags, ...constants.default.nodeMemoryFlags, ...(constants.default.ENV.INLINED_SOCKET_CLI_SENTRY_BUILD ? ['--require', constants.default.instrumentWithSentryPath] : []), '--require', constants.default.shadowNpmInjectPath, agent.resolveBinPathSync(agentExecPath), 'install',
  // Avoid code paths for 'audit' and 'fund'.
  '--no-audit', '--no-fund',
  // Add '--no-progress' to fix input being swallowed by the npm spinner.
  '--no-progress',
  // Add 'FLAG_LOGLEVEL silent' if a loglevel flag is not provided and the
  // SOCKET_CLI_DEBUG environment variable is not truthy.
  ...logLevelArgs, ...binArgs, ...otherArgs], {
    ...spawnOpts,
    env: {
      ...process.env,
      ...constants.default.processEnv,
      ...require$$11.getOwn(spawnOpts, 'env')
    },
    spinner,
    stdio
  });
  if (useIpc) {
    spawnPromise.process.send({
      [constants.default.SOCKET_IPC_HANDSHAKE]: {
        [constants.default.SOCKET_CLI_SHADOW_BIN]: constants.NPM,
        [constants.default.SOCKET_CLI_SHADOW_PROGRESS]: progressArg,
        ...ipc
      }
    });
  }
  return spawnPromise;
}

/**
 * Package manager agent utilities for Socket CLI.
 * Manages package installation via different package managers.
 *
 * Key Functions:
 * - runAgentInstall: Execute package installation with detected agent
 *
 * Supported Agents:
 * - npm: Node Package Manager
 * - pnpm: Fast, disk space efficient package manager
 * - yarn: Alternative package manager
 *
 * Features:
 * - Automatic agent detection
 * - Shadow installation for security scanning
 * - Spinner support for progress indication
 */

function runAgentInstall(pkgEnvDetails, options) {
  const {
    agent,
    agentExecPath,
    pkgPath
  } = pkgEnvDetails;
  const isNpm = agent === constants.NPM;
  const isPnpm = agent === constants.PNPM;
  // All package managers support the "install" command.
  if (isNpm) {
    return shadowNpmInstall({
      agentExecPath,
      cwd: pkgPath,
      ...options
    });
  }
  const {
    args = [],
    spinner,
    ...spawnOpts
  } = {
    __proto__: null,
    ...options
  };
  const skipNodeHardenFlags = isPnpm && pkgEnvDetails.agentVersion.major < 11;
  // In CI mode, pnpm uses --frozen-lockfile by default, which prevents lockfile updates.
  // We need to explicitly disable it when updating the lockfile with overrides.
  // Also add --config.confirmModulesPurge=false to avoid interactive prompts.
  const installArgs = isPnpm ? ['install', '--config.confirmModulesPurge=false', '--no-frozen-lockfile', ...args] : ['install', ...args];
  return spawn.spawn(agentExecPath, installArgs, {
    cwd: pkgPath,
    // On Windows, package managers are often .cmd files that require shell execution.
    // The spawn function from @socketsecurity/registry will handle this properly
    // when shell is true.
    shell: constants.default.WIN32,
    spinner,
    stdio: 'inherit',
    ...spawnOpts,
    env: {
      ...process.env,
      ...constants.default.processEnv,
      // Set CI for pnpm to ensure non-interactive mode and consistent behavior.
      ...(isPnpm ? {
        CI: '1'
      } : {}),
      NODE_OPTIONS: cmdFlagsToString([...(skipNodeHardenFlags ? [] : constants.default.nodeHardenFlags), ...constants.default.nodeNoWarningsFlags]),
      ...require$$11.getOwn(spawnOpts, 'env')
    }
  });
}

/**
 * Package environment detection utilities for Socket CLI.
 * Analyzes project environment and package manager configuration.
 *
 * Key Functions:
 * - getPackageEnvironment: Detect package manager and project details
 * - makeConcurrentExecLimit: Calculate concurrent execution limits
 *
 * Environment Detection:
 * - Detects npm, pnpm, yarn, bun package managers
 * - Analyzes lockfiles for version information
 * - Determines Node.js and engine requirements
 * - Identifies workspace configurations
 *
 * Features:
 * - Browser target detection via browserslist
 * - Engine compatibility checking
 * - Package manager version detection
 * - Workspace and monorepo support
 *
 * Usage:
 * - Auto-detecting appropriate package manager
 * - Validating environment compatibility
 * - Configuring concurrent execution limits
 */

const {
  BUN,
  BUN_LOCK,
  BUN_LOCKB,
  DOT_PACKAGE_LOCK_JSON,
  EXT_LOCK,
  EXT_LOCKB,
  NODE_MODULES,
  NPM,
  NPM_BUGGY_OVERRIDES_PATCHED_VERSION,
  NPM_SHRINKWRAP_JSON,
  PACKAGE_JSON,
  PNPM,
  VLT,
  VLT_LOCK_JSON,
  YARN,
  YARN_BERRY,
  YARN_CLASSIC
} = constants.default;
const AGENTS = [BUN, NPM, PNPM, YARN_BERRY, YARN_CLASSIC, VLT];
const binByAgent = new Map([[BUN, BUN], [NPM, NPM], [PNPM, PNPM], [YARN_BERRY, YARN], [YARN_CLASSIC, YARN], [VLT, VLT]]);
const readLockFileByAgent = (() => {
  function wrapReader(reader) {
    return async (...args) => {
      try {
        return await reader(...args);
      } catch {}
      return undefined;
    };
  }
  const binaryReader = wrapReader(fs.readFileBinary);
  const defaultReader = wrapReader(async lockPath => await fs.readFileUtf8(lockPath));
  return new Map([[BUN, wrapReader(async (lockPath, agentExecPath, cwd = process.cwd()) => {
    const ext = path.extname(lockPath);
    if (ext === EXT_LOCK) {
      return await defaultReader(lockPath);
    }
    if (ext === EXT_LOCKB) {
      const lockBuffer = await binaryReader(lockPath);
      if (lockBuffer) {
        try {
          return vendor.hyrious__bun_lockbExports.parse(lockBuffer);
        } catch {}
      }
      // To print a Yarn lockfile to your console without writing it to disk
      // use `bun bun.lockb`.
      // https://bun.sh/guides/install/yarnlock
      return (await spawn.spawn(agentExecPath, [lockPath], {
        cwd,
        // On Windows, bun is often a .cmd file that requires shell execution.
        // The spawn function from @socketsecurity/registry will handle this properly
        // when shell is true.
        shell: constants.default.WIN32
      })).stdout;
    }
    return undefined;
  })], [NPM, defaultReader], [PNPM, defaultReader], [VLT, defaultReader], [YARN_BERRY, defaultReader], [YARN_CLASSIC, defaultReader]]);
})();

// The order of LOCKS properties IS significant as it affects iteration order.
const LOCKS = {
  [BUN_LOCK]: BUN,
  [BUN_LOCKB]: BUN,
  // If both package-lock.json and npm-shrinkwrap.json are present in the root
  // of a project, npm-shrinkwrap.json will take precedence and package-lock.json
  // will be ignored.
  // https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json#package-lockjson-vs-npm-shrinkwrapjson
  [NPM_SHRINKWRAP_JSON]: NPM,
  [constants.PACKAGE_LOCK_JSON]: NPM,
  [constants.PNPM_LOCK_YAML]: PNPM,
  [constants.YARN_LOCK]: YARN_CLASSIC,
  [VLT_LOCK_JSON]: VLT,
  // Lastly, look for a hidden lockfile which is present if .npmrc has package-lock=false:
  // https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json#hidden-lockfiles
  //
  // Unlike the other LOCKS keys this key contains a directory AND filename so
  // it has to be handled differently.
  [`${NODE_MODULES}/${DOT_PACKAGE_LOCK_JSON}`]: NPM
};
async function getAgentExecPath(agent) {
  const binName = binByAgent.get(agent);
  if (binName === NPM) {
    // Try to use constants.npmExecPath first, but verify it exists.
    const npmPath = constants.default.npmExecPath;
    if (fs$1.existsSync(npmPath)) {
      return npmPath;
    }
    // If npmExecPath doesn't exist, try common locations.
    // Check npm in the same directory as node.
    const nodeDir = path.dirname(process.execPath);
    const npmInNodeDir = path.join(nodeDir, NPM);
    if (fs$1.existsSync(npmInNodeDir)) {
      return npmInNodeDir;
    }
    // Fall back to whichBin.
    return (await bin.whichBin(binName, {
      nothrow: true
    })) ?? binName;
  }
  if (binName === PNPM) {
    // Try to use constants.pnpmExecPath first, but verify it exists.
    const pnpmPath = constants.default.pnpmExecPath;
    if (fs$1.existsSync(pnpmPath)) {
      return pnpmPath;
    }
    // Fall back to whichBin.
    return (await bin.whichBin(binName, {
      nothrow: true
    })) ?? binName;
  }
  return (await bin.whichBin(binName, {
    nothrow: true
  })) ?? binName;
}
async function getAgentVersion(agent, agentExecPath, cwd) {
  let result;
  const quotedCmd = `\`${agent} ${constants.FLAG_VERSION}\``;
  require$$9.debugFn('stdio', `spawn: ${quotedCmd}`);
  try {
    result =
    // Coerce version output into a valid semver version by passing it through
    // semver.coerce which strips leading v's, carets (^), comparators (<,<=,>,>=,=),
    // and tildes (~).
    vendor.semverExports.coerce(
    // All package managers support the "--version" flag.
    (await spawn.spawn(agentExecPath, [constants.FLAG_VERSION], {
      cwd,
      // On Windows, package managers are often .cmd files that require shell execution.
      // The spawn function from @socketsecurity/registry will handle this properly
      // when shell is true.
      shell: constants.default.WIN32
    })).stdout) ?? undefined;
  } catch (e) {
    require$$9.debugFn('error', `Package manager command failed: ${quotedCmd}`);
    require$$9.debugDir('inspect', {
      cmd: quotedCmd
    });
    require$$9.debugDir('error', e);
  }
  return result;
}
async function detectPackageEnvironment({
  cwd = process.cwd(),
  onUnknown
} = {}) {
  let lockPath = await findUp(Object.keys(LOCKS), {
    cwd
  });
  let lockName = lockPath ? path.basename(lockPath) : undefined;
  const isHiddenLockFile = lockName === DOT_PACKAGE_LOCK_JSON;
  const pkgJsonPath = lockPath ? path.resolve(lockPath, `${isHiddenLockFile ? '../' : ''}../${PACKAGE_JSON}`) : await findUp(PACKAGE_JSON, {
    cwd
  });
  const pkgPath = pkgJsonPath && fs$1.existsSync(pkgJsonPath) ? path.dirname(pkgJsonPath) : undefined;
  const editablePkgJson = pkgPath ? await packages.readPackageJson(pkgPath, {
    editable: true
  }) : undefined;
  // Read Corepack `packageManager` field in package.json:
  // https://nodejs.org/api/packages.html#packagemanager
  const pkgManager = strings.isNonEmptyString(editablePkgJson?.content?.packageManager) ? editablePkgJson.content.packageManager : undefined;
  let agent;
  if (pkgManager) {
    // A valid "packageManager" field value is "<package manager name>@<version>".
    // https://nodejs.org/api/packages.html#packagemanager
    const atSignIndex = pkgManager.lastIndexOf('@');
    if (atSignIndex !== -1) {
      const name = pkgManager.slice(0, atSignIndex);
      const version = pkgManager.slice(atSignIndex + 1);
      if (version && AGENTS.includes(name)) {
        agent = name;
      }
    }
  }
  if (agent === undefined && !isHiddenLockFile && typeof pkgJsonPath === 'string' && typeof lockName === 'string') {
    agent = LOCKS[lockName];
  }
  if (agent === undefined) {
    agent = NPM;
    onUnknown?.(pkgManager);
  }
  const agentExecPath = await getAgentExecPath(agent);
  const agentVersion = await getAgentVersion(agent, agentExecPath, cwd);
  if (agent === YARN_CLASSIC && (agentVersion?.major ?? 0) > 1) {
    agent = YARN_BERRY;
  }
  const {
    maintainedNodeVersions
  } = constants.default;
  const minSupportedAgentVersion = constants.default.minimumVersionByAgent.get(agent);
  const minSupportedNodeMajor = vendor.semverExports.major(maintainedNodeVersions.last);
  const minSupportedNodeVersion = `${minSupportedNodeMajor}.0.0`;
  const minSupportedNodeRange = `>=${minSupportedNodeMajor}`;
  const nodeVersion = vendor.semverExports.coerce(process.version);
  let lockSrc;
  let pkgAgentRange;
  let pkgNodeRange;
  let pkgMinAgentVersion = minSupportedAgentVersion;
  let pkgMinNodeVersion = minSupportedNodeVersion;
  if (editablePkgJson?.content) {
    const {
      engines
    } = editablePkgJson.content;
    const engineAgentRange = engines?.[agent];
    const engineNodeRange = engines?.['node'];
    if (strings.isNonEmptyString(engineAgentRange)) {
      pkgAgentRange = engineAgentRange;
      // Roughly check agent range as semver.coerce will strip leading
      // v's, carets (^), comparators (<,<=,>,>=,=), and tildes (~).
      const coerced = vendor.semverExports.coerce(pkgAgentRange);
      if (coerced && vendor.semverExports.lt(coerced, pkgMinAgentVersion)) {
        pkgMinAgentVersion = coerced.version;
      }
    }
    if (strings.isNonEmptyString(engineNodeRange)) {
      pkgNodeRange = engineNodeRange;
      // Roughly check Node range as semver.coerce will strip leading
      // v's, carets (^), comparators (<,<=,>,>=,=), and tildes (~).
      const coerced = vendor.semverExports.coerce(pkgNodeRange);
      if (coerced && vendor.semverExports.lt(coerced, pkgMinNodeVersion)) {
        pkgMinNodeVersion = coerced.version;
      }
    }
    const browserslistQuery = editablePkgJson.content['browserslist'];
    if (Array.isArray(browserslistQuery)) {
      // List Node targets in ascending version order.
      const browserslistNodeTargets = vendor.browserslistExports(browserslistQuery).filter(v => /^node /i.test(v)).map(v => v.slice(5 /*'node '.length*/)).sort(sorts.naturalCompare);
      if (browserslistNodeTargets.length) {
        // browserslistNodeTargets[0] is the lowest Node target version.
        const coerced = vendor.semverExports.coerce(browserslistNodeTargets[0]);
        if (coerced && vendor.semverExports.lt(coerced, pkgMinNodeVersion)) {
          pkgMinNodeVersion = coerced.version;
        }
      }
    }
    lockSrc = typeof lockPath === 'string' ? await readLockFileByAgent.get(agent)(lockPath, agentExecPath, cwd) : undefined;
  } else {
    lockName = undefined;
    lockPath = undefined;
  }

  // Does the system agent version meet our minimum supported agent version?
  const agentSupported = !!agentVersion && vendor.semverExports.satisfies(agentVersion, `>=${minSupportedAgentVersion}`);
  // Does the system Node version meet our minimum supported Node version?
  const nodeSupported = vendor.semverExports.satisfies(nodeVersion, minSupportedNodeRange);
  const npmExecPath = agent === NPM ? agentExecPath : await getAgentExecPath(NPM);
  const npmBuggyOverrides = agent === NPM && !!agentVersion && vendor.semverExports.lt(agentVersion, NPM_BUGGY_OVERRIDES_PATCHED_VERSION);
  const pkgMinAgentRange = `>=${pkgMinAgentVersion}`;
  const pkgMinNodeRange = `>=${vendor.semverExports.major(pkgMinNodeVersion)}`;
  return {
    agent,
    agentExecPath,
    agentSupported,
    agentVersion,
    editablePkgJson,
    features: {
      npmBuggyOverrides
    },
    lockName,
    lockPath,
    lockSrc,
    nodeSupported,
    nodeVersion,
    npmExecPath,
    pkgPath,
    pkgRequirements: {
      agent: pkgAgentRange ?? pkgMinAgentRange,
      node: pkgNodeRange ?? pkgMinNodeRange
    },
    pkgSupports: {
      // Does our minimum supported agent version meet the package's requirements?
      agent: vendor.semverExports.satisfies(minSupportedAgentVersion, pkgMinAgentRange),
      // Does our supported Node versions meet the package's requirements?
      node: maintainedNodeVersions.some(v => vendor.semverExports.satisfies(v, pkgMinNodeRange))
    }
  };
}
async function detectAndValidatePackageEnvironment(cwd, options) {
  const {
    cmdName = '',
    logger,
    prod
  } = {
    __proto__: null,
    ...options
  };
  const details = await detectPackageEnvironment({
    cwd,
    onUnknown(pkgManager) {
      logger?.warn(cmdPrefixMessage(cmdName, `Unknown package manager${pkgManager ? ` ${pkgManager}` : ''}, defaulting to ${NPM}`));
    }
  });
  const {
    agent,
    nodeVersion,
    pkgRequirements
  } = details;
  const agentVersion = details.agentVersion ?? 'unknown';
  if (!details.agentSupported) {
    const minVersion = constants.default.minimumVersionByAgent.get(agent);
    return {
      ok: false,
      message: 'Version mismatch',
      cause: cmdPrefixMessage(cmdName, `Requires ${agent} >=${minVersion}. Current version: ${agentVersion}.`)
    };
  }
  if (!details.nodeSupported) {
    const minVersion = constants.default.maintainedNodeVersions.last;
    return {
      ok: false,
      message: 'Version mismatch',
      cause: cmdPrefixMessage(cmdName, `Requires Node >=${minVersion}. Current version: ${nodeVersion}.`)
    };
  }
  if (!details.pkgSupports.agent) {
    return {
      ok: false,
      message: 'Engine mismatch',
      cause: cmdPrefixMessage(cmdName, `Package engine "${agent}" requires ${pkgRequirements.agent}. Current version: ${agentVersion}`)
    };
  }
  if (!details.pkgSupports.node) {
    return {
      ok: false,
      message: 'Version mismatch',
      cause: cmdPrefixMessage(cmdName, `Package engine "node" requires ${pkgRequirements.node}. Current version: ${nodeVersion}`)
    };
  }
  const lockName = details.lockName ?? 'lockfile';
  if (details.lockName === undefined || details.lockSrc === undefined) {
    return {
      ok: false,
      message: 'Missing lockfile',
      cause: cmdPrefixMessage(cmdName, `No ${lockName} found`)
    };
  }
  if (details.lockSrc.trim() === '') {
    return {
      ok: false,
      message: 'Empty lockfile',
      cause: cmdPrefixMessage(cmdName, `${lockName} is empty`)
    };
  }
  if (details.pkgPath === undefined) {
    return {
      ok: false,
      message: 'Missing package.json',
      cause: cmdPrefixMessage(cmdName, `No ${PACKAGE_JSON} found`)
    };
  }
  if (prod && (agent === BUN || agent === YARN_BERRY)) {
    return {
      ok: false,
      message: 'Bad input',
      cause: cmdPrefixMessage(cmdName, `--prod not supported for ${agent}${agentVersion ? `@${agentVersion}` : ''}`)
    };
  }
  if (details.lockPath && path.relative(cwd, details.lockPath).startsWith('.')) {
    // Note: In tests we return <redacted> because otherwise snapshots will fail.
    logger?.warn(cmdPrefixMessage(cmdName, `Package ${lockName} found at ${constants.default.ENV.VITEST ? constants.default.REDACTED : details.lockPath}`));
  }
  return {
    ok: true,
    data: details
  };
}

/**
 * Ecosystem type utilities for Socket CLI.
 * Manages package ecosystem identifiers and mappings.
 *
 * Constants:
 * - ALL_ECOSYSTEMS: Complete list of supported ecosystems
 * - ECOSYSTEM_MAP: Map ecosystem strings to PURL types
 *
 * Type Definitions:
 * - PURL_Type: Package URL type from Socket SDK
 *
 * Supported Ecosystems:
 * - apk, bitbucket, cargo, chrome, cocoapods, composer
 * - conan, conda, cran, deb, docker, gem, generic
 * - github, gitlab, go, hackage, hex, huggingface
 * - maven, mlflow, npm, nuget, oci, pub, pypi, rpm, swift
 *
 * Usage:
 * - Validates ecosystem types
 * - Maps between different ecosystem representations
 * - Ensures type safety for ecosystem operations
 */

const ALL_ECOSYSTEMS = ['apk', 'bitbucket', 'cargo', 'chrome', 'cocoapods', 'composer', 'conan', 'conda', 'cran', 'deb', 'docker', 'gem', 'generic', 'github', 'golang', 'hackage', 'hex', 'huggingface', 'maven', 'mlflow', constants.NPM, 'nuget', 'oci', 'pub', 'pypi', 'qpkg', 'rpm', 'swift', 'swid', 'unknown'];
new Set(ALL_ECOSYSTEMS);
function getEcosystemChoicesForMeow() {
  return [...ALL_ECOSYSTEMS];
}

/**
 * Temporary package executor detection utilities for Socket CLI.
 * Identifies and handles temporary execution contexts.
 *
 * Key Functions:
 * - isRunningInTemporaryExecutor: Detects if running in npx/dlx/exec context
 * - shouldSkipShadow: Determines if shadow installation should be skipped
 *
 * Temporary Execution Contexts:
 * - npm exec/npx: Runs packages in temporary npm cache
 * - pnpm dlx: Executes packages in temporary pnpm store
 * - yarn dlx: Runs packages in temporary yarn environment
 *
 * Detection Methods:
 * - Environment variable analysis (npm_config_user_agent)
 * - Path pattern matching for temporary directories
 * - Cache directory identification
 *
 * Usage:
 * - Prevents shadow installation in temporary contexts
 * - Avoids PATH pollution in ephemeral environments
 * - Ensures package manager commands work correctly
 */

/**
 * Determines if shadow binaries should be installed.
 * Shadows should NOT be installed when:
 * - Running in a temporary execution context (exec/npx/dlx)
 * - On Windows with an existing binary path (required for Windows to function)
 *
 * @param binPath - Path to the binary being shadowed
 * @param options - Configuration options
 * @param options.cwd - Current working directory path to check
 * @param options.win32 - Whether running on Windows
 * @returns true if shadow installation should be skipped
 */
function shouldSkipShadow(binPath, options) {
  const {
    cwd = process.cwd(),
    win32 = false
  } = {
    __proto__: null,
    ...options
  };

  // Windows compatibility: Skip shadow installation if binary is already found.
  //
  // This check is required because Windows handles executables differently than Unix:
  // 1. File locking - Windows locks running executables, so cmd-shim creation would
  //    fail with EBUSY/EACCES errors when trying to create wrapper files.
  // 2. PATH conflicts - Attempting to shadow an already-resolved binary can create
  //    circular references or ambiguous command resolution.
  // 3. Registry integration - Windows package managers often use system-level
  //    integrations beyond just PATH that our shadowing would interfere with.
  //
  // Without this check, users would see "Access Denied" or file locking errors
  // that are difficult to debug. This is not a performance optimization - the
  // shadow installation will fail without it.
  if (win32 && binPath) {
    return true;
  }

  // Check environment variable for exec/npx/dlx indicators.
  const userAgent = constants.default.ENV.npm_config_user_agent;
  if (userAgent?.includes('exec') || userAgent?.includes('npx') || userAgent?.includes('dlx')) {
    return true;
  }

  // Normalize the cwd path for consistent checking across platforms.
  const normalizedCwd = path$1.normalizePath(cwd);

  // Check if running from npm's npx cache.
  const npmCache = constants.default.ENV.npm_config_cache;
  if (npmCache && normalizedCwd.includes(path$1.normalizePath(npmCache))) {
    return true;
  }

  // Check common temporary execution path patterns.
  const tempPatterns = ['_npx',
  // npm's npx cache directory
  '.pnpm-store',
  // pnpm dlx temporary store
  'dlx-',
  // Common dlx directory prefix
  '.yarn/$$',
  // Yarn Berry PnP virtual packages
  path.sep === '\\' ? 'AppData\\Local\\Temp\\xfs-' : 'AppData/Local/Temp/xfs-' // Yarn on Windows
  ];
  return tempPatterns.some(pattern => normalizedCwd.includes(pattern));
}

/**
 * PNPM path resolution utilities for Socket CLI.
 * Locates and caches PNPM binary paths.
 *
 * Key Functions:
 * - getPnpmBinPath: Get cached PNPM binary path
 * - getPnpmBinPathDetails: Get detailed PNPM path information
 *
 * Error Handling:
 * - Exits with code 127 if PNPM not found
 * - Provides clear error messages for missing binaries
 *
 * Caching:
 * - Caches binary path lookups for performance
 * - Prevents repeated PATH searches
 */

function exitWithBinPathError(binName) {
  logger.logger.fail(`Socket unable to locate ${binName}; ensure it is available in the PATH environment variable`);
  // The exit code 127 indicates that the command or binary being executed
  // could not be found.
  // eslint-disable-next-line n/no-process-exit
  process.exit(127);
  // This line is never reached in production, but helps tests.
  throw new Error('process.exit called');
}
let _pnpmBinPath;
function getPnpmBinPath() {
  if (_pnpmBinPath === undefined) {
    _pnpmBinPath = getPnpmBinPathDetails().path;
    if (!_pnpmBinPath) {
      exitWithBinPathError('pnpm');
    }
  }
  return _pnpmBinPath;
}
let _pnpmBinPathDetails;
function getPnpmBinPathDetails() {
  if (_pnpmBinPathDetails === undefined) {
    _pnpmBinPathDetails = findBinPathDetailsSync('pnpm');
  }
  return _pnpmBinPathDetails;
}
function isPnpmBinPathShadowed() {
  return getPnpmBinPathDetails().shadowed;
}

/**
 * Shadow binary link installation utilities for Socket CLI.
 * Manages installation of shadow binaries for package managers.
 *
 * Key Functions:
 * - installNpmLinks: Install shadow links for npm binary
 * - installNpxLinks: Install shadow links for npx binary
 * - installPnpmLinks: Install shadow links for pnpm binary
 * - installYarnLinks: Install shadow links for yarn binary
 *
 * Shadow Installation:
 * - Creates symlinks/cmd-shims to intercept package manager commands
 * - Modifies PATH to prioritize shadow binaries
 * - Skips installation in temporary execution contexts
 *
 * Security Integration:
 * - Enables security scanning before package operations
 * - Transparent interception of package manager commands
 * - Preserves original binary functionality
 */

const __filename$1 = require$$0.fileURLToPath((typeof document === 'undefined' ? require$$0.pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('utils.js', document.baseURI).href)));
const __dirname$1 = path.dirname(__filename$1);
async function installNpmLinks(shadowBinPath) {
  // Find npm being shadowed by this process.
  const binPath = getNpmBinPath();
  const {
    WIN32
  } = constants.default;

  // Skip shadow installation when in temporary execution context or when required for Windows.
  if (shouldSkipShadow(binPath, {
    cwd: __dirname$1,
    win32: WIN32
  })) {
    return binPath;
  }
  const shadowed = isNpmBinPathShadowed();
  // Move our bin directory to front of PATH so its found first.
  if (!shadowed) {
    if (WIN32) {
      await vendor.libExports(path.join(constants.default.distPath, 'npm-cli.js'), path.join(shadowBinPath, 'npm'));
    }
    const {
      env
    } = process;
    env['PATH'] = `${shadowBinPath}${path.delimiter}${env['PATH']}`;
  }
  return binPath;
}
async function installNpxLinks(shadowBinPath) {
  // Find npx being shadowed by this process.
  const binPath = getNpxBinPath();
  const {
    WIN32
  } = constants.default;

  // Skip shadow installation when in temporary execution context or when required for Windows.
  if (shouldSkipShadow(binPath, {
    cwd: __dirname$1,
    win32: WIN32
  })) {
    return binPath;
  }
  const shadowed = isNpxBinPathShadowed();
  // Move our bin directory to front of PATH so its found first.
  if (!shadowed) {
    if (WIN32) {
      await vendor.libExports(path.join(constants.default.distPath, 'npx-cli.js'), path.join(shadowBinPath, 'npx'));
    }
    const {
      env
    } = process;
    env['PATH'] = `${shadowBinPath}${path.delimiter}${env['PATH']}`;
  }
  return binPath;
}
async function installPnpmLinks(shadowBinPath) {
  // Find pnpm being shadowed by this process.
  const binPath = getPnpmBinPath();
  const {
    WIN32
  } = constants.default;

  // Skip shadow installation when in temporary execution context or when required for Windows.
  if (shouldSkipShadow(binPath, {
    cwd: __dirname$1,
    win32: WIN32
  })) {
    return binPath;
  }
  const shadowed = isPnpmBinPathShadowed();

  // Move our bin directory to front of PATH so its found first.
  if (!shadowed) {
    if (WIN32) {
      await vendor.libExports(path.join(constants.default.distPath, 'pnpm-cli.js'), path.join(shadowBinPath, 'pnpm'));
    }
    const {
      env
    } = process;
    env['PATH'] = `${shadowBinPath}${path.delimiter}${env['PATH']}`;
  }
  return binPath;
}
async function installYarnLinks(shadowBinPath) {
  const binPath = getYarnBinPath();
  const {
    WIN32
  } = constants.default;

  // Skip shadow installation when in temporary execution context or when required for Windows.
  if (shouldSkipShadow(binPath, {
    cwd: __dirname$1,
    win32: WIN32
  })) {
    return binPath;
  }
  const shadowed = isYarnBinPathShadowed();
  if (!shadowed) {
    if (WIN32) {
      await vendor.libExports(path.join(constants.default.distPath, 'yarn-cli.js'), path.join(shadowBinPath, 'yarn'));
    }
    const {
      env
    } = process;
    env['PATH'] = `${shadowBinPath}${path.delimiter}${env['PATH']}`;
  }
  return binPath;
}

/**
 * Filter configuration utilities for Socket CLI.
 * Manages filter configuration normalization for security scanning.
 *
 * Key Functions:
 * - toFilterConfig: Normalize filter configuration objects
 *
 * Usage:
 * - Normalizes user-provided filter objects
 * - Ensures proper structure for filter configuration
 * - Validates boolean and array values
 */

function toFilterConfig(obj) {
  const normalized = {
    __proto__: null
  };
  const keys = require$$11.isObject(obj) ? Object.keys(obj) : [];
  for (const key of keys) {
    const value = obj[key];
    if (typeof value === 'boolean' || Array.isArray(value)) {
      normalized[key] = value;
    }
  }
  return normalized;
}

function idToNpmPurl(id) {
  return `pkg:${constants.NPM}/${id}`;
}

async function extractPurlsFromPnpmLockfile(lockfile) {
  const packages = lockfile?.packages ?? {};
  const seen = new Set();
  const visit = pkgPath => {
    if (seen.has(pkgPath)) {
      return;
    }
    const pkg = packages[pkgPath];
    if (!pkg) {
      return;
    }
    seen.add(pkgPath);
    const deps = {
      __proto__: null,
      ...pkg.dependencies,
      ...pkg.optionalDependencies,
      ...pkg.devDependencies
    };
    for (const depName in deps) {
      const ref = deps[depName];
      const subKey = isPnpmDepPath(ref) ? ref : `/${depName}@${ref}`;
      visit(subKey);
    }
  };
  for (const pkgPath of Object.keys(packages)) {
    visit(pkgPath);
  }
  return Array.from(seen).map(p => idToNpmPurl(stripPnpmPeerSuffix(stripLeadingPnpmDepPathSlash(p))));
}
function isPnpmDepPath(maybeDepPath) {
  return maybeDepPath.length > 0 && maybeDepPath.charCodeAt(0) === 47; /*'/'*/
}
function parsePnpmLockfile(lockfileContent) {
  let result;
  if (typeof lockfileContent === 'string') {
    try {
      result = vendor.jsYaml.load(strings.stripBom(lockfileContent));
    } catch {}
  }
  return require$$11.isObjectObject(result) ? result : null;
}
async function readPnpmLockfile(lockfilePath) {
  return fs$1.existsSync(lockfilePath) ? await fs.readFileUtf8(lockfilePath) : undefined;
}
function stripLeadingPnpmDepPathSlash(depPath) {
  return isPnpmDepPath(depPath) ? depPath.slice(1) : depPath;
}
function stripPnpmPeerSuffix(depPath) {
  const parenIndex = depPath.indexOf('(');
  const index = parenIndex === -1 ? depPath.indexOf('_') : parenIndex;
  return index === -1 ? depPath : depPath.slice(0, index);
}

function isArtifactAlertCve(alert) {
  const {
    type
  } = alert;
  return type === constants.default.ALERT_TYPE_CVE || type === constants.default.ALERT_TYPE_MEDIUM_CVE || type === constants.default.ALERT_TYPE_MILD_CVE || type === constants.default.ALERT_TYPE_CRITICAL_CVE;
}

function createEnum(obj) {
  return Object.freeze({
    __proto__: null,
    ...obj
  });
}

const ALERT_FIX_TYPE = createEnum({
  cve: 'cve',
  remove: 'remove',
  upgrade: 'upgrade'
});

const ALERT_SEVERITY = createEnum({
  critical: 'critical',
  high: 'high',
  middle: 'middle',
  low: 'low'
});

/**
 * Color and markdown formatting utilities for Socket CLI.
 * Provides dual-mode formatting for terminal colors or markdown output.
 *
 * Key Class:
 * - ColorOrMarkdown: Dual-mode formatter for terminal/markdown output
 *
 * Formatting Methods:
 * - bold: Bold text formatting
 * - codeBlock: Code block formatting
 * - codeInline: Inline code formatting
 * - header: Section headers
 * - hyperlink: Clickable links
 * - indent: Text indentation
 * - italic: Italic text formatting
 * - list: Bullet list formatting
 * - table: Table formatting
 *
 * Usage:
 * - Switches between terminal colors and markdown based on output format
 * - Supports both interactive terminal and report generation
 * - Handles hyperlink fallbacks for terminals without link support
 */

class ColorOrMarkdown {
  constructor(useMarkdown) {
    this.useMarkdown = !!useMarkdown;
  }
  bold(text) {
    return this.useMarkdown ? `**${text}**` : vendor.yoctocolorsCjsExports.bold(`${text}`);
  }
  header(text, level = 1) {
    return this.useMarkdown ? `\n${''.padStart(level, '#')} ${text}\n` : vendor.yoctocolorsCjsExports.underline(`\n${level === 1 ? vendor.yoctocolorsCjsExports.bold(text) : text}\n`);
  }
  hyperlink(text, url, {
    fallback = true,
    fallbackToUrl
  } = {}) {
    if (url) {
      return this.useMarkdown ? `[${text}](${url})` : vendor.terminalLinkExports(text, url, {
        fallback: fallbackToUrl ? (_text, url) => url : fallback
      });
    }
    return text;
  }
  indent(...args) {
    return vendor.indentStringExports(...args);
  }
  italic(text) {
    return this.useMarkdown ? `_${text}_` : vendor.yoctocolorsCjsExports.italic(`${text}`);
  }
  json(value) {
    return this.useMarkdown ? '```json\n' + JSON.stringify(value) + '\n```' : JSON.stringify(value);
  }
  list(items) {
    const indentedContent = items.map(item => this.indent(item).trimStart());
    return this.useMarkdown ? `* ${indentedContent.join('\n* ')}\n` : `${indentedContent.join('\n')}\n`;
  }
}

const require$1 = require$$5.createRequire((typeof document === 'undefined' ? require$$0.pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('utils.js', document.baseURI).href)));
let _translations;
function getTranslations() {
  if (_translations === undefined) {
    _translations = /*@__PURE__*/require$1(path.join(constants.default.rootPath, 'translations.json'));
  }
  return _translations;
}

/**
 * Socket package alert utilities for Socket CLI.
 * Handles security alerts, vulnerabilities, and package risk assessment.
 *
 * Key Functions:
 * - addArtifactToAlertsMap: Add security alert to package map
 * - logAlertsMap: Display alerts in formatted output
 * - shouldSkipPackageAlert: Filter alerts based on criteria
 *
 * Alert Types:
 * - CVE: Common Vulnerabilities and Exposures
 * - GHSA: GitHub Security Advisories
 * - Package quality issues
 * - Supply chain risks
 *
 * Features:
 * - Alert severity classification (critical/high/medium/low)
 * - Fix type detection (major/minor/patch/none)
 * - Alert filtering and suppression
 * - Colorized terminal output
 */

const ALERT_SEVERITY_COLOR = createEnum({
  critical: 'magenta',
  high: 'red',
  middle: 'yellow',
  low: 'white'
});
const ALERT_SEVERITY_ORDER = createEnum({
  critical: 0,
  high: 1,
  middle: 2,
  low: 3,
  none: 4
});
const MIN_ABOVE_THE_FOLD_COUNT = 3;
const MIN_ABOVE_THE_FOLD_ALERT_COUNT = 1;
const format = new ColorOrMarkdown(false);
function getHiddenRiskCounts(hiddenAlerts) {
  const riskCounts = {
    critical: 0,
    high: 0,
    middle: 0,
    low: 0
  };
  for (const alert of hiddenAlerts) {
    switch (getAlertSeverityOrder(alert)) {
      case ALERT_SEVERITY_ORDER.critical:
        riskCounts.critical += 1;
        break;
      case ALERT_SEVERITY_ORDER.high:
        riskCounts.high += 1;
        break;
      case ALERT_SEVERITY_ORDER.middle:
        riskCounts.middle += 1;
        break;
      case ALERT_SEVERITY_ORDER.low:
        riskCounts.low += 1;
        break;
    }
  }
  return riskCounts;
}
function getHiddenRisksDescription(riskCounts) {
  const descriptions = [];
  if (riskCounts.critical) {
    descriptions.push(`${riskCounts.critical} ${getSeverityLabel('critical')}`);
  }
  if (riskCounts.high) {
    descriptions.push(`${riskCounts.high} ${getSeverityLabel('high')}`);
  }
  if (riskCounts.middle) {
    descriptions.push(`${riskCounts.middle} ${getSeverityLabel('middle')}`);
  }
  if (riskCounts.low) {
    descriptions.push(`${riskCounts.low} ${getSeverityLabel('low')}`);
  }
  return `(${descriptions.join('; ')})`;
}
async function addArtifactToAlertsMap(artifact, alertsByPurl, options) {
  // Make TypeScript happy.
  if (!artifact.name || !artifact.version || !artifact.alerts?.length) {
    return alertsByPurl;
  }
  const {
    type: ecosystem,
    version
  } = artifact;
  const {
    consolidate = false,
    overrides,
    socketYml
  } = {
    __proto__: null,
    ...options
  };
  const name = packages.resolvePackageName(artifact);
  const filterConfig = toFilterConfig({
    blocked: true,
    critical: true,
    cve: true,
    ...require$$11.getOwn(options, 'filter')
  });
  const enabledState = {
    __proto__: null,
    ...socketYml?.issueRules
  };
  let sockPkgAlerts = [];
  for (const alert of artifact.alerts) {
    const action = alert.action ?? '';
    const enabledFlag = enabledState[alert.type];
    if (action === 'ignore' && enabledFlag !== true || enabledFlag === false) {
      continue;
    }
    const blocked = action === 'error';
    const critical = alert.severity === ALERT_SEVERITY.critical;
    const cve = isArtifactAlertCve(alert);
    const fixType = alert.fix?.type ?? '';
    const fixableCve = fixType === ALERT_FIX_TYPE.cve;
    const fixableUpgrade = fixType === ALERT_FIX_TYPE.upgrade;
    const fixable = fixableCve || fixableUpgrade;
    const upgradable = fixableUpgrade && !require$$11.hasOwn(overrides, name);
    if (filterConfig.blocked && blocked || filterConfig.critical && critical || filterConfig.cve && cve || filterConfig.fixable && fixable || filterConfig.upgradable && upgradable) {
      sockPkgAlerts.push({
        name,
        version,
        key: alert.key,
        type: alert.type,
        blocked,
        critical,
        ecosystem,
        fixable,
        raw: alert,
        upgradable
      });
    }
  }
  if (!sockPkgAlerts.length) {
    return alertsByPurl;
  }
  const purl = `pkg:${ecosystem}/${name}@${version}`;
  const major = getMajor(version);
  if (consolidate) {
    const highestForCve = new Map();
    const highestForUpgrade = new Map();
    const unfixableAlerts = [];
    for (const sockPkgAlert of sockPkgAlerts) {
      const alert = sockPkgAlert.raw;
      const fixType = alert.fix?.type ?? '';
      if (fixType === ALERT_FIX_TYPE.cve) {
        // An alert with alert.fix.type of 'cve' should have a
        // alert.props.firstPatchedVersionIdentifier property value.
        // We're just being cautious.
        const firstPatchedVersionIdentifier = alert.props?.firstPatchedVersionIdentifier;
        const patchedMajor = firstPatchedVersionIdentifier ? getMajor(firstPatchedVersionIdentifier) : null;
        if (typeof patchedMajor === 'number') {
          // Consolidate to the highest "first patched version" by each major
          // version number.
          const highest = highestForCve.get(patchedMajor)?.version ?? '0.0.0';
          if (vendor.semverExports.gt(firstPatchedVersionIdentifier, highest)) {
            highestForCve.set(patchedMajor, {
              alert: sockPkgAlert,
              version: firstPatchedVersionIdentifier
            });
          }
        } else {
          unfixableAlerts.push(sockPkgAlert);
        }
      } else if (fixType === ALERT_FIX_TYPE.upgrade) {
        // For Socket Optimize upgrades we assume the highest version available
        // is compatible. This may change in the future.
        const highest = highestForUpgrade.get(major)?.version ?? '0.0.0';
        if (vendor.semverExports.gt(version, highest)) {
          highestForUpgrade.set(major, {
            alert: sockPkgAlert,
            version
          });
        }
      } else {
        unfixableAlerts.push(sockPkgAlert);
      }
    }
    sockPkgAlerts = [
    // Sort CVE alerts by severity: critical, high, middle, then low.
    ...Array.from(highestForCve.values()).map(d => d.alert).sort(alertSeverityComparator), ...Array.from(highestForUpgrade.values()).map(d => d.alert), ...unfixableAlerts];
  } else {
    sockPkgAlerts.sort((a, b) => sorts.naturalCompare(a.type, b.type));
  }
  if (sockPkgAlerts.length) {
    alertsByPurl.set(purl, sockPkgAlerts);
  }
  return alertsByPurl;
}
function alertsHaveBlocked(alerts) {
  return alerts.find(a => a.blocked) !== undefined;
}
function alertsHaveSeverity(alerts, severity) {
  return alerts.find(a => a.raw.severity === severity) !== undefined;
}
function alertSeverityComparator(a, b) {
  // Put the most severe first.
  return getAlertSeverityOrder(a) - getAlertSeverityOrder(b);
}
function getAlertSeverityOrder(alert) {
  // The more severe, the lower the sort number.
  const {
    severity
  } = alert.raw;
  return severity === ALERT_SEVERITY.critical ? 0 : severity === ALERT_SEVERITY.high ? 1 : severity === ALERT_SEVERITY.middle ? 2 : severity === ALERT_SEVERITY.low ? 3 : 4;
}
function getAlertsSeverityOrder(alerts) {
  return alertsHaveBlocked(alerts) || alertsHaveSeverity(alerts, ALERT_SEVERITY.critical) ? 0 : alertsHaveSeverity(alerts, ALERT_SEVERITY.high) ? 1 : alertsHaveSeverity(alerts, ALERT_SEVERITY.middle) ? 2 : alertsHaveSeverity(alerts, ALERT_SEVERITY.low) ? 3 : 4;
}
function getSeverityLabel(severity) {
  return severity === 'middle' ? 'moderate' : severity;
}
function logAlertsMap(alertsMap, options) {
  const {
    hideAt = 'middle',
    output = process.stderr
  } = {
    __proto__: null,
    ...options
  };
  const translations = getTranslations();
  const sortedEntries = Array.from(alertsMap.entries()).sort((a, b) => getAlertsSeverityOrder(a[1]) - getAlertsSeverityOrder(b[1]));
  const aboveTheFoldPurls = new Set();
  const viewableAlertsByPurl = new Map();
  const hiddenAlertsByPurl = new Map();
  for (let i = 0, {
      length
    } = sortedEntries; i < length; i += 1) {
    const {
      0: purl,
      1: alerts
    } = sortedEntries[i];
    const hiddenAlerts = [];
    const viewableAlerts = alerts.filter(a => {
      const keep = a.blocked || getAlertSeverityOrder(a) < ALERT_SEVERITY_ORDER[hideAt];
      if (!keep) {
        hiddenAlerts.push(a);
      }
      return keep;
    });
    if (hiddenAlerts.length) {
      hiddenAlertsByPurl.set(purl, hiddenAlerts.sort(alertSeverityComparator));
    }
    if (!viewableAlerts.length) {
      continue;
    }
    viewableAlerts.sort(alertSeverityComparator);
    viewableAlertsByPurl.set(purl, viewableAlerts);
    if (viewableAlerts.find(a => a.blocked || getAlertSeverityOrder(a) < ALERT_SEVERITY_ORDER.middle)) {
      aboveTheFoldPurls.add(purl);
    }
  }

  // If MIN_ABOVE_THE_FOLD_COUNT is NOT met add more from viewable pkg ids.
  for (const {
    0: purl
  } of viewableAlertsByPurl.entries()) {
    if (aboveTheFoldPurls.size >= MIN_ABOVE_THE_FOLD_COUNT) {
      break;
    }
    aboveTheFoldPurls.add(purl);
  }
  // If MIN_ABOVE_THE_FOLD_COUNT is STILL NOT met add more from hidden pkg ids.
  for (const {
    0: purl,
    1: hiddenAlerts
  } of hiddenAlertsByPurl.entries()) {
    if (aboveTheFoldPurls.size >= MIN_ABOVE_THE_FOLD_COUNT) {
      break;
    }
    aboveTheFoldPurls.add(purl);
    const viewableAlerts = viewableAlertsByPurl.get(purl) ?? [];
    if (viewableAlerts.length < MIN_ABOVE_THE_FOLD_ALERT_COUNT) {
      const neededCount = MIN_ABOVE_THE_FOLD_ALERT_COUNT - viewableAlerts.length;
      let removedHiddenAlerts;
      if (hiddenAlerts.length - neededCount > 0) {
        removedHiddenAlerts = hiddenAlerts.splice(0, MIN_ABOVE_THE_FOLD_ALERT_COUNT);
      } else {
        removedHiddenAlerts = hiddenAlerts;
        hiddenAlertsByPurl.delete(purl);
      }
      viewableAlertsByPurl.set(purl, [...viewableAlerts, ...removedHiddenAlerts]);
    }
  }
  const mentionedPurlsWithHiddenAlerts = new Set();
  for (let i = 0, prevAboveTheFold = true, entries = Array.from(viewableAlertsByPurl.entries()), {
      length
    } = entries; i < length; i += 1) {
    const {
      0: purl,
      1: alerts
    } = entries[i];
    const lines = new Set();
    for (const alert of alerts) {
      const {
        type
      } = alert;
      const severity = alert.raw.severity ?? '';
      const attributes = [...(severity ? [vendor.yoctocolorsCjsExports[ALERT_SEVERITY_COLOR[severity]](getSeverityLabel(severity))] : []), ...(alert.blocked ? [vendor.yoctocolorsCjsExports.bold(vendor.yoctocolorsCjsExports.red('blocked'))] : []), ...(alert.fixable ? ['fixable'] : [])];
      const maybeAttributes = attributes.length ? ` ${vendor.yoctocolorsCjsExports.italic(`(${attributes.join('; ')})`)}` : '';
      // Based data from { pageProps: { alertTypes } } of:
      // https://socket.dev/_next/data/9a6db8224b68b6da0eb9f7dbb17aff7e51568ac2/en-US.json
      const info = translations.alerts[type];
      const title = info?.title ?? type;
      const maybeDesc = info?.description ? ` - ${info.description}` : '';
      const content = `${title}${maybeAttributes}${maybeDesc}`;
      // TODO: An added emoji seems to mis-align terminals sometimes.
      lines.add(`  ${content}`);
    }
    const purlObj = getPurlObject(purl);
    const pkgName = packages.resolvePackageName(purlObj);
    const hyperlink = format.hyperlink(`${pkgName}@${purlObj.version}`, getSocketDevPackageOverviewUrl(purlObj.type, pkgName, purlObj.version));
    const isAboveTheFold = aboveTheFoldPurls.has(purl);
    if (isAboveTheFold) {
      aboveTheFoldPurls.add(purl);
      output.write(`${i ? '\n' : ''}${hyperlink}:\n`);
    } else {
      output.write(`${prevAboveTheFold ? '\n' : ''}${hyperlink}:\n`);
    }
    for (const line of lines) {
      output.write(`${line}\n`);
    }
    const hiddenAlerts = hiddenAlertsByPurl.get(purl) ?? [];
    const {
      length: hiddenAlertsCount
    } = hiddenAlerts;
    if (hiddenAlertsCount) {
      mentionedPurlsWithHiddenAlerts.add(purl);
      if (hiddenAlertsCount === 1) {
        output.write(`  ${vendor.yoctocolorsCjsExports.dim(`+1 Hidden ${getSeverityLabel(hiddenAlerts[0].raw.severity ?? 'low')} risk alert`)}\n`);
      } else {
        output.write(`  ${vendor.yoctocolorsCjsExports.dim(`+${hiddenAlertsCount} Hidden alerts ${vendor.yoctocolorsCjsExports.italic(getHiddenRisksDescription(getHiddenRiskCounts(hiddenAlerts)))}`)}\n`);
      }
    }
    prevAboveTheFold = isAboveTheFold;
  }
  const additionalHiddenCount = hiddenAlertsByPurl.size - mentionedPurlsWithHiddenAlerts.size;
  if (additionalHiddenCount) {
    const totalRiskCounts = {
      critical: 0,
      high: 0,
      middle: 0,
      low: 0
    };
    for (const {
      0: purl,
      1: alerts
    } of hiddenAlertsByPurl.entries()) {
      if (mentionedPurlsWithHiddenAlerts.has(purl)) {
        continue;
      }
      const riskCounts = getHiddenRiskCounts(alerts);
      totalRiskCounts.critical += riskCounts.critical;
      totalRiskCounts.high += riskCounts.high;
      totalRiskCounts.middle += riskCounts.middle;
      totalRiskCounts.low += riskCounts.low;
    }
    output.write(`${aboveTheFoldPurls.size ? '\n' : ''}${vendor.yoctocolorsCjsExports.dim(`${aboveTheFoldPurls.size ? '+' : ''}${additionalHiddenCount} Packages with hidden alerts ${vendor.yoctocolorsCjsExports.italic(getHiddenRisksDescription(totalRiskCounts))}`)}\n`);
  }
  output.write('\n');
}

/**
 * Alerts map utilities for Socket CLI.
 * Manages security alerts and vulnerability mappings for packages.
 *
 * Key Functions:
 * - getAlertsMapFromPnpmLockfile: Extract alerts from pnpm lockfile
 * - getAlertsMapFromPurls: Get alerts for specific package URLs
 * - processAlertsApiResponse: Process API response into alerts map
 *
 * Alert Processing:
 * - Filters alerts based on socket.yml configuration
 * - Maps package URLs to security vulnerabilities
 * - Supports batch processing for performance
 *
 * Integration:
 * - Works with pnpm lockfiles for dependency scanning
 * - Uses Socket API for vulnerability data
 * - Respects filter configurations from socket.yml
 */

async function getAlertsMapFromPnpmLockfile(lockfile, options) {
  const purls = await extractPurlsFromPnpmLockfile(lockfile);
  return await getAlertsMapFromPurls(purls, {
    overrides: lockfile.overrides,
    ...options
  });
}
async function getAlertsMapFromPurls(purls, options) {
  const uniqPurls = arrays.arrayUnique(purls);
  require$$9.debugDir('silly', {
    purls: uniqPurls
  });
  let {
    length: remaining
  } = uniqPurls;
  const alertsByPurl = new Map();
  if (!remaining) {
    return alertsByPurl;
  }
  const opts = {
    __proto__: null,
    consolidate: false,
    nothrow: false,
    ...options,
    filter: toFilterConfig(require$$11.getOwn(options, 'filter'))
  };
  if (opts.onlyFixable) {
    opts.filter.fixable = true;
  }
  const {
    apiToken = getPublicApiToken(),
    spinner
  } = opts;
  const getText = () => `Looking up data for ${remaining} packages`;
  spinner?.start(getText());
  const sockSdkCResult = await setupSdk({
    apiToken
  });
  if (!sockSdkCResult.ok) {
    spinner?.stop();
    throw new Error('Auth error: Run `socket login` first.');
  }
  const sockSdk = sockSdkCResult.data;
  const socketYmlResult = findSocketYmlSync();
  const socketYml = socketYmlResult.ok && socketYmlResult.data ? socketYmlResult.data.parsed : undefined;
  const alertsMapOptions = {
    consolidate: opts.consolidate,
    filter: opts.filter,
    overrides: opts.overrides,
    socketYml,
    spinner
  };
  try {
    for await (const batchResult of sockSdk.batchPackageStream({
      components: uniqPurls.map(purl => ({
        purl
      }))
    }, {
      queryParams: {
        alerts: 'true',
        compact: 'true',
        ...(opts.onlyFixable ? {
          fixable: 'true '
        } : {}),
        ...(Array.isArray(opts.filter.actions) ? {
          actions: opts.filter.actions.join(',')
        } : {})
      }
    })) {
      if (batchResult.success) {
        const artifact = batchResult.data;
        await addArtifactToAlertsMap(artifact, alertsByPurl, alertsMapOptions);
      } else if (!opts.nothrow) {
        spinner?.stop();
        if (strings.isNonEmptyString(batchResult.error)) {
          throw new Error(batchResult.error);
        }
        const statusCode = batchResult.status ?? 'unknown';
        throw new Error(`Socket API server error (${statusCode}): No status message`);
      } else {
        spinner?.stop();
        logger.logger.fail(`Received a ${batchResult.status} response from Socket API which we consider a permanent failure:`, batchResult.error, batchResult.cause ? `( ${batchResult.cause} )` : '');
        require$$9.debugDir('inspect', {
          batchResult
        });
        break;
      }
      remaining -= 1;
      if (remaining > 0) {
        spinner?.start(getText());
      }
    }
  } catch (e) {
    spinner?.stop();
    throw e;
  }
  spinner?.stop();
  return alertsByPurl;
}

/**
 * npm package specification utilities for Socket CLI.
 * Parses and handles various npm package specification formats.
 *
 * Supported Formats:
 * - Regular packages: lodash, lodash@4.17.21
 * - Scoped packages: @types/node, @types/node@20.0.0
 * - Version ranges: lodash@^4.0.0, lodash@~4.17.0
 * - Git URLs: git+https://github.com/user/repo.git
 * - File paths: file:../local-package
 * - Aliases: my-alias@npm:real-package@1.0.0
 *
 * Key Functions:
 * - safeNpa: Safe wrapper for npm-package-arg
 * - safeNpmSpecToPurl: Convert npm spec to PURL
 * - safeParseNpmSpec: Parse npm spec to name/version
 *
 * Error Handling:
 * - Returns undefined for invalid specs
 * - Fallback parsing for edge cases
 * - Safe against malformed input
 */


// @ts-expect-error - Result is re-exported below.

/**
 * Safe wrapper for npm-package-arg that doesn't throw.
 * Returns undefined if parsing fails.
 */
function safeNpa(...args) {
  try {
    return Reflect.apply(vendor.npaExports, undefined, args);
  } catch {}
  return undefined;
}

/**
 * Parse npm package specification into name and version.
 * Uses npm-package-arg for proper handling of various spec formats:
 * - Regular packages: lodash, lodash@4.17.21
 * - Scoped packages: @types/node, @types/node@20.0.0
 * - Version ranges: lodash@^4.0.0
 * - Git URLs, file paths, etc.
 *
 * Returns undefined if parsing fails.
 */
function safeParseNpmSpec(pkgSpec) {
  // Use npm-package-arg for proper spec parsing.
  const parsed = safeNpa(pkgSpec);
  if (!parsed) {
    // Fallback to simple parsing if npm-package-arg fails.
    // Handle scoped packages first to avoid confusion with version delimiter.
    if (pkgSpec.startsWith('@')) {
      const scopedMatch = pkgSpec.match(/^(@[^/@]+\/[^/@]+)(?:@(.+))?$/);
      if (scopedMatch) {
        return {
          name: scopedMatch[1],
          version: scopedMatch[2]
        };
      }
    }

    // Handle regular packages.
    const atIndex = pkgSpec.indexOf('@');
    if (atIndex === -1) {
      return {
        name: pkgSpec,
        version: undefined
      };
    }
    return {
      name: pkgSpec.slice(0, atIndex),
      version: pkgSpec.slice(atIndex + 1)
    };
  }

  // Extract name and version from parsed spec.
  const name = parsed.name || pkgSpec;
  let version;

  // Handle different spec types from npm-package-arg.
  if (parsed.type === 'tag' || parsed.type === 'version' || parsed.type === 'range') {
    // For npm registry packages:
    // - type 'tag': latest, beta, etc.
    // - type 'version': exact version like 1.0.0
    // - type 'range': version range like ^1.0.0, ~1.0.0, or * for bare names
    // Don't include '*' as a version - it means "any version".
    if (parsed.fetchSpec && parsed.fetchSpec !== '*') {
      version = parsed.fetchSpec;
    } else if (parsed.rawSpec && parsed.rawSpec !== '*' && parsed.rawSpec !== parsed.name) {
      version = parsed.rawSpec;
    }
  } else if (parsed.type === 'git' || parsed.type === 'remote' || parsed.type === 'file') {
    // For non-registry specs, use rawSpec if different from name.
    if (parsed.rawSpec && parsed.rawSpec !== parsed.name) {
      version = parsed.rawSpec;
    }
  }
  return {
    name,
    version
  };
}

/**
 * Convert npm package spec to PURL string.
 * Handles various npm spec formats and converts them to standardized PURLs.
 * Returns undefined if conversion fails.
 */
function safeNpmSpecToPurl(pkgSpec) {
  const parsed = safeParseNpmSpec(pkgSpec);
  if (!parsed) {
    return undefined;
  }
  const {
    name,
    version
  } = parsed;

  // Create PURL object to ensure proper formatting.
  const purlObj = createPurlObject({
    type: constants.NPM,
    name,
    version,
    throws: false
  });
  return purlObj?.toString() ?? `pkg:${constants.NPM}/${name}${version ? `@${version}` : ''}`;
}

exports.AuthError = AuthError;
exports.COMPLETION_CMD_PREFIX = COMPLETION_CMD_PREFIX;
exports.InputError = InputError;
exports.RangeStyles = RangeStyles;
exports.cacheFetch = cacheFetch;
exports.captureException = captureException;
exports.checkCommandInput = checkCommandInput;
exports.cmdFlagValueToArray = cmdFlagValueToArray;
exports.cmdFlagsToString = cmdFlagsToString;
exports.cmdPrefixMessage = cmdPrefixMessage;
exports.convertCveToGhsa = convertCveToGhsa;
exports.convertPurlToGhsas = convertPurlToGhsas;
exports.createEnum = createEnum;
exports.debugFileOp = debugFileOp;
exports.debugScan = debugScan;
exports.detectAndValidatePackageEnvironment = detectAndValidatePackageEnvironment;
exports.detectDefaultBranch = detectDefaultBranch;
exports.determineOrgSlug = determineOrgSlug;
exports.enablePrAutoMerge = enablePrAutoMerge;
exports.extractTier1ReachabilityScanId = extractTier1ReachabilityScanId;
exports.failMsgWithBadge = failMsgWithBadge;
exports.fetchGhsaDetails = fetchGhsaDetails;
exports.fetchOrganization = fetchOrganization;
exports.fileLink = fileLink;
exports.filterFlags = filterFlags;
exports.findUp = findUp;
exports.formatErrorWithDetail = formatErrorWithDetail;
exports.getAlertsMapFromPnpmLockfile = getAlertsMapFromPnpmLockfile;
exports.getAlertsMapFromPurls = getAlertsMapFromPurls;
exports.getBaseBranch = getBaseBranch;
exports.getBashrcDetails = getBashrcDetails;
exports.getConfigValue = getConfigValue;
exports.getConfigValueOrUndef = getConfigValueOrUndef;
exports.getDefaultOrgSlug = getDefaultOrgSlug;
exports.getEcosystemChoicesForMeow = getEcosystemChoicesForMeow;
exports.getEnterpriseOrgs = getEnterpriseOrgs;
exports.getErrorCause = getErrorCause;
exports.getFlagApiRequirementsOutput = getFlagApiRequirementsOutput;
exports.getFlagListOutput = getFlagListOutput;
exports.getMajor = getMajor;
exports.getNpmBinPath = getNpmBinPath;
exports.getNpmRequire = getNpmRequire;
exports.getNpxBinPath = getNpxBinPath;
exports.getOctokit = getOctokit;
exports.getOctokitGraphql = getOctokitGraphql;
exports.getOrgSlugs = getOrgSlugs;
exports.getOutputKind = getOutputKind;
exports.getPackageFilesForScan = getPackageFilesForScan;
exports.getPublicApiToken = getPublicApiToken;
exports.getPurlObject = getPurlObject;
exports.getRepoInfo = getRepoInfo;
exports.getRepoName = getRepoName;
exports.getSocketDevPackageOverviewUrlFromPurl = getSocketDevPackageOverviewUrlFromPurl;
exports.getSupportedConfigEntries = getSupportedConfigEntries;
exports.getSupportedConfigKeys = getSupportedConfigKeys;
exports.getVisibleTokenPrefix = getVisibleTokenPrefix;
exports.gitBranch = gitBranch;
exports.gitCheckoutBranch = gitCheckoutBranch;
exports.gitCommit = gitCommit;
exports.gitCreateBranch = gitCreateBranch;
exports.gitDeleteBranch = gitDeleteBranch;
exports.gitPushBranch = gitPushBranch;
exports.gitRemoteBranchExists = gitRemoteBranchExists;
exports.gitResetAndClean = gitResetAndClean;
exports.gitUnstagedModifiedFiles = gitUnstagedModifiedFiles;
exports.globWorkspace = globWorkspace;
exports.handleApiCall = handleApiCall;
exports.handleApiCallNoSpinner = handleApiCallNoSpinner;
exports.hasDefaultApiToken = hasDefaultApiToken;
exports.hasEnterpriseOrgPlan = hasEnterpriseOrgPlan;
exports.idToNpmPurl = idToNpmPurl;
exports.installNpmLinks = installNpmLinks;
exports.installNpxLinks = installNpxLinks;
exports.installPnpmLinks = installPnpmLinks;
exports.installYarnLinks = installYarnLinks;
exports.isAddCommand = isAddCommand;
exports.isConfigFromFlag = isConfigFromFlag;
exports.isHelpFlag = isHelpFlag;
exports.isPnpmLockfileScanCommand = isPnpmLockfileScanCommand;
exports.isReportSupportedFile = isReportSupportedFile;
exports.isSensitiveConfigKey = isSensitiveConfigKey;
exports.isSupportedConfigKey = isSupportedConfigKey;
exports.isYarnBerry = isYarnBerry;
exports.logAlertsMap = logAlertsMap;
exports.mailtoLink = mailtoLink;
exports.mapToObject = mapToObject;
exports.mdTable = mdTable;
exports.mdTableOfPairs = mdTableOfPairs;
exports.mdTableStringNumber = mdTableStringNumber;
exports.meowOrExit = meowOrExit;
exports.meowWithSubcommands = meowWithSubcommands;
exports.msAtHome = msAtHome;
exports.normalizePurl = normalizePurl;
exports.parsePnpmLockfile = parsePnpmLockfile;
exports.queryApiSafeJson = queryApiSafeJson;
exports.queryApiSafeText = queryApiSafeText;
exports.readOrDefaultSocketJson = readOrDefaultSocketJson;
exports.readOrDefaultSocketJsonUp = readOrDefaultSocketJsonUp;
exports.readPnpmLockfile = readPnpmLockfile;
exports.readSocketJsonSync = readSocketJsonSync;
exports.runAgentInstall = runAgentInstall;
exports.safeNpa = safeNpa$1;
exports.safeNpmSpecToPurl = safeNpmSpecToPurl;
exports.sendApiRequest = sendApiRequest;
exports.serializeResultJson = serializeResultJson;
exports.setGitRemoteGithubRepoUrl = setGitRemoteGithubRepoUrl;
exports.setupSdk = setupSdk;
exports.socketDashboardLink = socketDashboardLink;
exports.socketDevLink = socketDevLink;
exports.socketDocsLink = socketDocsLink;
exports.socketPackageLink = socketPackageLink;
exports.spawnCdxgenDlx = spawnCdxgenDlx;
exports.spawnCoanaDlx = spawnCoanaDlx;
exports.spawnSynpDlx = spawnSynpDlx;
exports.suggestOrgSlug = suggestOrgSlug;
exports.tildify = tildify;
exports.toFilterConfig = toFilterConfig;
exports.updateConfigValue = updateConfigValue;
exports.walkNestedMap = walkNestedMap;
exports.webLink = webLink;
exports.writeSocketJson = writeSocketJson;
//# debugId=4869ae24-405b-42c5-8d8a-e03b6c950c8e
//# sourceMappingURL=utils.js.map
