{"version":3,"file":"shadow-npm-inject.js","sources":["../src/shadow/npm/paths.mts","../src/shadow/npm/arborist/types.mts","../src/shadow/npm/arborist-helpers.mts","../src/shadow/npm/arborist/lib/arborist/index.mts","../src/shadow/npm/arborist/index.mts","../src/shadow/npm/inject.mts"],"sourcesContent":["import path from 'node:path'\n\nimport { normalizePath } from '@socketsecurity/registry/lib/path'\n\nimport constants from '../../constants.mts'\nimport { getNpmRequire } from '../../utils/npm-paths.mts'\n\nlet _arboristPkgPath: string | undefined\nexport function getArboristPackagePath() {\n  if (_arboristPkgPath === undefined) {\n    const pkgName = '@npmcli/arborist'\n    const mainPathWithForwardSlashes = normalizePath(\n      getNpmRequire().resolve(pkgName),\n    )\n    const arboristPkgPathWithForwardSlashes = mainPathWithForwardSlashes.slice(\n      0,\n      mainPathWithForwardSlashes.lastIndexOf(pkgName) + pkgName.length,\n    )\n    _arboristPkgPath = constants.WIN32\n      ? path.normalize(arboristPkgPathWithForwardSlashes)\n      : arboristPkgPathWithForwardSlashes\n  }\n  return _arboristPkgPath\n}\n\nlet _arboristClassPath: string | undefined\nexport function getArboristClassPath() {\n  if (_arboristClassPath === undefined) {\n    _arboristClassPath = path.join(\n      getArboristPackagePath(),\n      'lib/arborist/index.js',\n    )\n  }\n  return _arboristClassPath\n}\n\nlet _arboristEdgeClassPath: string | undefined\nexport function getArboristEdgeClassPath() {\n  if (_arboristEdgeClassPath === undefined) {\n    _arboristEdgeClassPath = path.join(getArboristPackagePath(), 'lib/edge.js')\n  }\n  return _arboristEdgeClassPath\n}\n\nlet _arboristNodeClassPath: string | undefined\nexport function getArboristNodeClassPath() {\n  if (_arboristNodeClassPath === undefined) {\n    _arboristNodeClassPath = path.join(getArboristPackagePath(), 'lib/node.js')\n  }\n  return _arboristNodeClassPath\n}\n\nlet _arboristOverrideSetClassPath: string | undefined\nexport function getArboristOverrideSetClassPath() {\n  if (_arboristOverrideSetClassPath === undefined) {\n    _arboristOverrideSetClassPath = path.join(\n      getArboristPackagePath(),\n      'lib/override-set.js',\n    )\n  }\n  return _arboristOverrideSetClassPath\n}\n","import { createEnum } from '../../../utils/objects.mts'\n\nimport type {\n  Advisory as BaseAdvisory,\n  Arborist as BaseArborist,\n  Options as BaseArboristOptions,\n  AuditReport as BaseAuditReport,\n  Diff as BaseDiff,\n  Edge as BaseEdge,\n  Node as BaseNode,\n  BaseOverrideSet,\n  BuildIdealTreeOptions,\n  ReifyOptions,\n} from '@npmcli/arborist'\n\nexport type ArboristOptions = BaseArboristOptions & {\n  npmCommand?: string | undefined\n  npmVersion?: string | undefined\n}\n\nexport type ArboristClass = ArboristInstance & {\n  new (...args: any): ArboristInstance\n}\n\nexport type ArboristInstance = Omit<\n  typeof BaseArborist,\n  | 'actualTree'\n  | 'auditReport'\n  | 'buildIdealTree'\n  | 'diff'\n  | 'idealTree'\n  | 'loadActual'\n  | 'loadVirtual'\n  | 'reify'\n> & {\n  auditReport?: AuditReportInstance | null | undefined\n  actualTree?: NodeClass | null | undefined\n  diff: Diff | null\n  idealTree?: NodeClass | null | undefined\n  buildIdealTree(\n    options?: BuildIdealTreeOptions | undefined,\n  ): Promise<NodeClass>\n  loadActual(options?: ArboristOptions | undefined): Promise<NodeClass>\n  loadVirtual(options?: ArboristOptions | undefined): Promise<NodeClass>\n  reify(options?: ArboristReifyOptions | undefined): Promise<NodeClass>\n}\n\nexport type ArboristReifyOptions = ReifyOptions & ArboristOptions\n\nexport type AuditAdvisory = Omit<BaseAdvisory, 'id'> & {\n  id: number\n  cwe: string[]\n  cvss: {\n    score: number\n    vectorString: string\n  }\n  vulnerable_versions: string\n}\n\nexport type AuditReportInstance = Omit<BaseAuditReport, 'report'> & {\n  report: { [dependency: string]: AuditAdvisory[] }\n}\n\nexport const DiffAction = createEnum({\n  add: 'ADD',\n  change: 'CHANGE',\n  remove: 'REMOVE',\n})\n\nexport type Diff = Omit<\n  BaseDiff,\n  | 'actual'\n  | 'children'\n  | 'filterSet'\n  | 'ideal'\n  | 'leaves'\n  | 'removed'\n  | 'shrinkwrapInflated'\n  | 'unchanged'\n> & {\n  actual: NodeClass\n  children: Diff[]\n  filterSet: Set<NodeClass>\n  ideal: NodeClass\n  leaves: NodeClass[]\n  parent: Diff | null\n  removed: NodeClass[]\n  shrinkwrapInflated: Set<NodeClass>\n  unchanged: NodeClass[]\n}\n\nexport type EdgeClass = Omit<\n  BaseEdge,\n  | 'accept'\n  | 'detach'\n  | 'optional'\n  | 'overrides'\n  | 'peer'\n  | 'peerConflicted'\n  | 'rawSpec'\n  | 'reload'\n  | 'satisfiedBy'\n  | 'spec'\n  | 'to'\n> & {\n  optional: boolean\n  overrides: OverrideSetClass | undefined\n  peer: boolean\n  peerConflicted: boolean\n  rawSpec: string\n  get accept(): string | undefined\n  get spec(): string\n  get to(): NodeClass | null\n  new (...args: any): EdgeClass\n  detach(): void\n  reload(hard?: boolean | undefined): void\n  satisfiedBy(node: NodeClass): boolean\n}\n\nexport type LinkClass = Omit<NodeClass, 'isLink'> & {\n  readonly isLink: true\n}\n\nexport type NodeClass = Omit<\n  BaseNode,\n  | 'addEdgeIn'\n  | 'addEdgeOut'\n  | 'canDedupe'\n  | 'canReplace'\n  | 'canReplaceWith'\n  | 'children'\n  | 'deleteEdgeIn'\n  | 'edgesIn'\n  | 'edgesOut'\n  | 'from'\n  | 'hasShrinkwrap'\n  | 'inDepBundle'\n  | 'inShrinkwrap'\n  | 'integrity'\n  | 'isTop'\n  | 'matches'\n  | 'meta'\n  | 'name'\n  | 'overrides'\n  | 'packageName'\n  | 'parent'\n  | 'recalculateOutEdgesOverrides'\n  | 'resolve'\n  | 'resolveParent'\n  | 'root'\n  | 'target'\n  | 'updateOverridesEdgeInAdded'\n  | 'updateOverridesEdgeInRemoved'\n  | 'version'\n  | 'versions'\n> & {\n  name: string\n  version: string\n  children: Map<string, NodeClass | LinkClass>\n  edgesIn: Set<EdgeClass>\n  edgesOut: Map<string, EdgeClass>\n  from: NodeClass | null\n  hasShrinkwrap: boolean\n  inShrinkwrap: boolean | undefined\n  integrity?: string | null\n  isTop: boolean | undefined\n  meta: BaseNode['meta'] & {\n    addEdge(edge: EdgeClass): void\n  }\n  overrides: OverrideSetClass | undefined\n  target: NodeClass\n  versions: string[]\n  get inDepBundle(): boolean\n  get packageName(): string | null\n  get parent(): NodeClass | null\n  set parent(value: NodeClass | null)\n  get resolveParent(): NodeClass | null\n  get root(): NodeClass | null\n  set root(value: NodeClass | null)\n  new (...args: any): NodeClass\n  addEdgeIn(edge: EdgeClass): void\n  addEdgeOut(edge: EdgeClass): void\n  canDedupe(preferDedupe?: boolean | undefined): boolean\n  canReplace(node: NodeClass, ignorePeers?: string[] | undefined): boolean\n  canReplaceWith(node: NodeClass, ignorePeers?: string[] | undefined): boolean\n  deleteEdgeIn(edge: EdgeClass): void\n  matches(node: NodeClass): boolean\n  recalculateOutEdgesOverrides(): void\n  resolve(name: string): NodeClass\n  updateOverridesEdgeInAdded(\n    otherOverrideSet: OverrideSetClass | undefined,\n  ): boolean\n  updateOverridesEdgeInRemoved(otherOverrideSet: OverrideSetClass): boolean\n}\n\nexport interface OverrideSetClass\n  extends Omit<\n    BaseOverrideSet,\n    | 'ancestry'\n    | 'children'\n    | 'getEdgeRule'\n    | 'getMatchingRule'\n    | 'getNodeRule'\n    | 'parent'\n    | 'ruleset'\n  > {\n  children: Map<string, OverrideSetClass>\n  key: string | undefined\n  keySpec: string | undefined\n  name: string | undefined\n  parent: OverrideSetClass | undefined\n  value: string | undefined\n  version: string | undefined\n  // eslint-disable-next-line @typescript-eslint/no-misused-new\n  new (...args: any[]): OverrideSetClass\n  get isRoot(): boolean\n  get ruleset(): Map<string, OverrideSetClass>\n  ancestry(): Generator<OverrideSetClass>\n  childrenAreEqual(otherOverrideSet: OverrideSetClass | undefined): boolean\n  getEdgeRule(edge: EdgeClass): OverrideSetClass\n  getMatchingRule(node: NodeClass): OverrideSetClass | null\n  getNodeRule(node: NodeClass): OverrideSetClass\n  isEqual(otherOverrideSet: OverrideSetClass | undefined): boolean\n}\n","import { debugFn } from '@socketsecurity/registry/lib/debug'\nimport { getOwn } from '@socketsecurity/registry/lib/objects'\nimport { parseUrl } from '@socketsecurity/registry/lib/url'\n\nimport constants from '../../constants.mts'\nimport { DiffAction } from './arborist/types.mts'\nimport { getAlertsMapFromPurls } from '../../utils/alerts-map.mts'\nimport { toFilterConfig } from '../../utils/filter-config.mts'\nimport { idToNpmPurl } from '../../utils/spec.mts'\n\nimport type { ArboristInstance, Diff, NodeClass } from './arborist/types.mts'\nimport type {\n  AlertFilter,\n  AlertsByPurl,\n} from '../../utils/socket-package-alert.mts'\nimport type { Spinner } from '@socketsecurity/registry/lib/spinner'\n\nfunction getUrlOrigin(input: string): string {\n  // TODO: URL.parse is available in Node 22.1.0. We can use it when we drop Node 18.\n  // https://nodejs.org/docs/latest-v22.x/api/url.html#urlparseinput-base\n  // return URL.parse(input)?.origin ?? ''\n  return parseUrl(input)?.origin ?? ''\n}\n\nexport type GetAlertsMapFromArboristOptions = {\n  apiToken?: string | undefined\n  consolidate?: boolean | undefined\n  filter?: AlertFilter | undefined\n  nothrow?: boolean | undefined\n  spinner?: Spinner | undefined\n}\n\nexport async function getAlertsMapFromArborist(\n  arb: ArboristInstance,\n  needInfoOn: PackageDetail[],\n  options?: GetAlertsMapFromArboristOptions | undefined,\n): Promise<AlertsByPurl> {\n  const opts = {\n    __proto__: null,\n    consolidate: false,\n    nothrow: false,\n    ...options,\n    filter: toFilterConfig(getOwn(options, 'filter')),\n  } as GetAlertsMapFromArboristOptions & { filter: AlertFilter }\n\n  const purls = needInfoOn.map(d => idToNpmPurl(d.node.pkgid))\n\n  let overrides: { [key: string]: string } | undefined\n  const overridesMap = (\n    arb.actualTree ??\n    arb.idealTree ??\n    (await arb.loadActual())\n  )?.overrides?.children\n  if (overridesMap) {\n    overrides = Object.fromEntries(\n      Array.from(overridesMap.entries()).map(([key, overrideSet]) => {\n        return [key, overrideSet.value!]\n      }),\n    )\n  }\n\n  return await getAlertsMapFromPurls(purls, {\n    overrides,\n    ...opts,\n  })\n}\n\nexport type DiffQueryFilter = {\n  existing?: boolean | undefined\n  unknownOrigin?: boolean | undefined\n}\n\nexport type DiffQueryOptions = {\n  filter?: DiffQueryFilter | undefined\n}\n\nexport type PackageDetail = {\n  node: NodeClass\n  existing?: NodeClass | undefined\n}\n\nexport function getDetailsFromDiff(\n  diff: Diff | null,\n  options?: DiffQueryOptions | undefined,\n): PackageDetail[] {\n  const details: PackageDetail[] = []\n  // `diff` is `null` when `npm install --package-lock-only` is passed.\n  if (!diff) {\n    debugFn('notice', `miss: diff is ${diff}`)\n    return details\n  }\n\n  const { NPM_REGISTRY_URL } = constants\n\n  const filterConfig = toFilterConfig({\n    existing: false,\n    unknownOrigin: true,\n    ...getOwn(options, 'filter'),\n  }) as DiffQueryFilter\n\n  const queue: Diff[] = [...diff.children]\n  let pos = 0\n  let { length: queueLength } = queue\n  while (pos < queueLength) {\n    if (pos === constants.LOOP_SENTINEL) {\n      throw new Error('Detected infinite loop while walking Arborist diff.')\n    }\n    const currDiff = queue[pos++]!\n    const { action } = currDiff\n    if (action) {\n      // The `pkgNode`, i.e. the `ideal` node, will be `undefined` if the diff\n      // action is 'REMOVE'\n      // The `oldNode`, i.e. the `actual` node, will be `undefined` if the diff\n      // action is 'ADD'.\n      const { actual: oldNode, ideal: pkgNode } = currDiff\n      let existing: NodeClass | undefined\n      let keep = false\n      if (action === DiffAction.change) {\n        if (pkgNode?.package.version !== oldNode?.package.version) {\n          keep = true\n          if (\n            oldNode?.package.name &&\n            oldNode.package.name === pkgNode?.package.name\n          ) {\n            existing = oldNode\n          }\n        }\n      } else {\n        keep = action !== DiffAction.remove\n      }\n      if (keep && pkgNode?.resolved && (!oldNode || oldNode.resolved)) {\n        if (\n          filterConfig.unknownOrigin ||\n          getUrlOrigin(pkgNode.resolved) === NPM_REGISTRY_URL\n        ) {\n          details.push({\n            node: pkgNode,\n            existing,\n          })\n        }\n      }\n    }\n    for (const child of currDiff.children) {\n      queue[queueLength++] = child\n    }\n  }\n  if (filterConfig.existing) {\n    const { unchanged } = diff\n    for (let i = 0, { length } = unchanged; i < length; i += 1) {\n      const pkgNode = unchanged[i]!\n      if (\n        filterConfig.unknownOrigin ||\n        getUrlOrigin(pkgNode.resolved!) === NPM_REGISTRY_URL\n      ) {\n        details.push({\n          node: pkgNode,\n          existing: pkgNode,\n        })\n      }\n    }\n  }\n  return details\n}\n","// @ts-ignore\nimport UntypedArborist from '@npmcli/arborist/lib/arborist/index.js'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants, { NODE_MODULES, NPX } from '../../../../../constants.mts'\nimport { findUp } from '../../../../../utils/fs.mts'\nimport { logAlertsMap } from '../../../../../utils/socket-package-alert.mts'\nimport {\n  getAlertsMapFromArborist,\n  getDetailsFromDiff,\n} from '../../../arborist-helpers.mts'\n\nimport type {\n  ArboristClass,\n  ArboristReifyOptions,\n  NodeClass,\n} from '../../types.mts'\n\nconst {\n  kInternalsSymbol,\n  [kInternalsSymbol as unknown as 'Symbol(kInternalsSymbol)']: { getIpc },\n} = constants\n\nexport const SAFE_NO_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES = {\n  __proto__: null,\n  audit: false,\n  dryRun: true,\n  fund: false,\n  ignoreScripts: true,\n  progress: false,\n  save: false,\n  saveBundle: false,\n  silent: true,\n}\n\nexport const SAFE_WITH_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES = {\n  // @ts-ignore\n  __proto__: null,\n  ...SAFE_NO_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES,\n  dryRun: false,\n  save: true,\n}\n\nexport const kCtorArgs = Symbol('ctorArgs')\n\nexport const kRiskyReify = Symbol('riskyReify')\n\nexport const Arborist: ArboristClass = UntypedArborist\n\n// Implementation code not related to our custom behavior is based on\n// https://github.com/npm/cli/blob/v11.0.0/workspaces/arborist/lib/arborist/index.js:\nexport class SafeArborist extends Arborist {\n  constructor(...ctorArgs: ConstructorParameters<ArboristClass>) {\n    super(\n      {\n        path:\n          (ctorArgs.length ? ctorArgs[0]?.path : undefined) ?? process.cwd(),\n        ...(ctorArgs.length ? ctorArgs[0] : undefined),\n        ...SAFE_NO_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES,\n      },\n      ...ctorArgs.slice(1),\n    )\n    ;(this as any)[kCtorArgs] = ctorArgs\n  }\n\n  async [kRiskyReify](\n    ...args: Parameters<InstanceType<ArboristClass>['reify']>\n  ): Promise<NodeClass> {\n    const ctorArgs = (this as any)[kCtorArgs]\n    const arb = new Arborist(\n      {\n        ...(ctorArgs.length ? ctorArgs[0] : undefined),\n        progress: false,\n      },\n      ...ctorArgs.slice(1),\n    )\n    const ret = await (arb.reify as (...args: any[]) => Promise<NodeClass>)(\n      {\n        ...(args.length ? args[0] : undefined),\n        progress: false,\n      },\n      ...args.slice(1),\n    )\n    Object.assign(this, arb)\n    return ret\n  }\n\n  // @ts-ignore Incorrectly typed.\n  override async reify(\n    this: SafeArborist,\n    ...args: Parameters<InstanceType<ArboristClass>['reify']>\n  ): Promise<NodeClass> {\n    const options = {\n      __proto__: null,\n      ...(args.length ? args[0] : undefined),\n    } as ArboristReifyOptions\n\n    const ipc = await getIpc()\n\n    const binName = ipc[constants.SOCKET_CLI_SHADOW_BIN]\n    if (!binName) {\n      return await this[kRiskyReify](...args)\n    }\n\n    await super.reify(\n      {\n        ...options,\n        ...SAFE_NO_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES,\n        progress: false,\n      },\n      // @ts-ignore: TypeScript gets grumpy about rest parameters.\n      ...args.slice(1),\n    )\n\n    const shadowAcceptRisks = !!ipc[constants.SOCKET_CLI_SHADOW_ACCEPT_RISKS]\n    const shadowProgress = !!ipc[constants.SOCKET_CLI_SHADOW_PROGRESS]\n    const shadowSilent = !!ipc[constants.SOCKET_CLI_SHADOW_SILENT]\n\n    const acceptRisks =\n      shadowAcceptRisks || constants.ENV.SOCKET_CLI_ACCEPT_RISKS\n    const reportOnlyBlocking = acceptRisks || options.dryRun || options['yes']\n    const silent = !!options['silent']\n    const spinner = silent || !shadowProgress ? undefined : constants.spinner\n\n    const isShadowNpx = binName === NPX\n    const hasExisting = await findUp(NODE_MODULES, {\n      cwd: process.cwd(),\n      onlyDirectories: true,\n    })\n    const shouldCheckExisting = reportOnlyBlocking ? true : isShadowNpx\n\n    const needInfoOn = getDetailsFromDiff(this.diff, {\n      filter: {\n        existing: shouldCheckExisting,\n      },\n    })\n\n    const alertsMap = await getAlertsMapFromArborist(this, needInfoOn, {\n      apiToken: ipc[constants.SOCKET_CLI_SHADOW_API_TOKEN],\n      spinner,\n      filter: reportOnlyBlocking\n        ? {\n            actions: ['error'],\n            blocked: true,\n            existing: shouldCheckExisting,\n          }\n        : {\n            actions: ['error', 'monitor', 'warn'],\n            existing: shouldCheckExisting,\n          },\n    })\n\n    if (alertsMap.size) {\n      process.exitCode = 1\n      const viewAllRisks = constants.ENV.SOCKET_CLI_VIEW_ALL_RISKS\n      logAlertsMap(alertsMap, {\n        hideAt: viewAllRisks ? 'none' : 'middle',\n        output: process.stderr,\n      })\n      throw new Error(\n        `\n          Socket ${binName} exiting due to risks.${\n            viewAllRisks\n              ? ''\n              : `\\nView all risks - Rerun with environment variable ${constants.SOCKET_CLI_VIEW_ALL_RISKS}=1.`\n          }${\n            acceptRisks\n              ? ''\n              : `\\nAccept risks - Rerun with environment variable ${constants.SOCKET_CLI_ACCEPT_RISKS}=1.`\n          }\n        `.trim(),\n      )\n    } else if (!silent && !shadowSilent) {\n      logger.success(\n        `Socket ${binName} ${acceptRisks ? 'accepted' : 'found no'}${hasExisting ? ' new' : ''} risks`,\n      )\n      if (isShadowNpx) {\n        logger.log(`Running ${options.add![0]}`)\n      }\n    }\n\n    return await this[kRiskyReify](...args)\n  }\n}\n","import { createRequire } from 'node:module'\n\n// @ts-ignore\nimport UntypedEdge from '@npmcli/arborist/lib/edge.js'\n// @ts-ignore\nimport UntypedNode from '@npmcli/arborist/lib/node.js'\n// @ts-ignore\nimport UntypedOverrideSet from '@npmcli/arborist/lib/override-set.js'\n\nimport {\n  getArboristClassPath,\n  getArboristEdgeClassPath,\n  getArboristNodeClassPath,\n  getArboristOverrideSetClassPath,\n} from '../paths.mts'\nimport { Arborist, SafeArborist } from './lib/arborist/index.mts'\n\nimport type { EdgeClass, NodeClass, OverrideSetClass } from './types.mts'\n\nconst require = createRequire(import.meta.url)\n\nexport { Arborist, SafeArborist }\n\nexport const Edge: EdgeClass = UntypedEdge\n\nexport const Node: NodeClass = UntypedNode\n\nexport const OverrideSet: OverrideSetClass = UntypedOverrideSet\n\nexport function installSafeArborist() {\n  // Override '@npmcli/arborist' module exports with patched variants based on\n  // https://github.com/npm/cli/pull/8089.\n  const cache: { [key: string]: any } = require.cache\n  cache[getArboristClassPath()] = { exports: SafeArborist }\n  cache[getArboristEdgeClassPath()] = { exports: Edge }\n  cache[getArboristNodeClassPath()] = { exports: Node }\n  cache[getArboristOverrideSetClassPath()] = { exports: OverrideSet }\n}\n","import { installSafeArborist } from './arborist/index.mts'\n\ninstallSafeArborist()\n"],"names":["_arboristPkgPath","add","change","remove","__proto__","consolidate","nothrow","debugFn","NPM_REGISTRY_URL","existing","unknownOrigin","length","action","actual","ideal","keep","node","queue","unchanged","getIpc","audit","dryRun","fund","ignoreScripts","progress","save","saveBundle","silent","path","Object","cwd","onlyDirectories","filter","apiToken","blocked","actions","hideAt","logger","cache","exports","installSafeArborist"],"mappings":";;;;;;;;;;;;;;AAOA;AACO;;;AAGH;AAGA;AAIAA;AAGF;AACA;AACF;AAEA;AACO;;;AAML;AACA;AACF;AAEA;AACO;;;AAGL;AACA;AACF;AAEA;AACO;;;AAGL;AACA;AACF;AAEA;AACO;;;AAML;AACA;AACF;;ACEO;AACLC;AACAC;AACAC;AACF;;AClDA;AACE;AACA;AACA;AACA;AACF;AAUO;AAKL;AACEC;AACAC;AACAC;AACA;;;AAIF;AAEA;;AAMA;;AAGM;AACF;AAEJ;AAEA;;;AAGA;AACF;AAgBO;;AAKL;;AAEEC;AACA;AACF;;AAEQC;AAAiB;;AAGvBC;AACAC;AACA;AACF;AAEA;;;AAEMC;AAAoB;;AAExB;AACE;AACF;AACA;;AACQC;AAAO;AACf;AACE;AACA;AACA;AACA;;AACQC;AAAiBC;AAAe;AACxC;;AAEA;;AAEIC;AACA;AAIEN;AACF;AACF;AACF;AACEM;AACF;AACA;AACE;;AAKIC;AACAP;AACF;AACF;AACF;AACF;AACA;AACEQ;AACF;AACF;;;AAEUC;AAAU;AAClB;AAAkBP;;AAChB;AACA;;AAKIK;AACAP;AACF;AACF;AACF;AACF;AACA;AACF;;AClKA;AAmBA;;AAEE;AAA+DU;AAAO;AACxE;AAEO;AACLf;AACAgB;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACF;AAUO;AAEA;AAEA;;AAEP;AACA;AACO;;AAEH;AAEIC;;;;AAOF;AACJ;AAEA;AAGE;AACA;;AAGIJ;;AAIJ;;AAGIA;;AAIJK;AACA;AACF;;AAEA;AACA;AAIE;AACEzB;;;AAIF;AAEA;;;AAGA;;AAII;AACA;AACAoB;;AAEF;AACA;;;;;;AAUF;;AAGA;AACA;AACEM;AACAC;AACF;AACA;AAEA;AACEC;AACEvB;AACF;AACF;;AAGEwB;;;;AAKMC;AACAzB;AACF;AAEE0B;AACA1B;AACF;AACN;;;AAIE;;AAEE2B;;AAEF;;AAGN;AAQA;AAGI;AACEC;AAGA;;AAEA;AACF;;AAGF;AACF;;ACrKA;AAIO;AAEA;AAEA;AAEA;AACL;AACA;AACA;AACAC;AAAkCC;;AAClCD;AAAsCC;;AACtCD;AAAsCC;;AACtCD;AAA6CC;;AAC/C;;ACnCAC","debugId":"fa30e366-2602-48d0-939f-fcec4c526adc"}